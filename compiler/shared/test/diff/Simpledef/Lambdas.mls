:NewDefs

:nolift
fun GetLambda(foo) =
    if foo == 1 then 
        (x) => x+5
    else 
        (x) => x+foo+10
GetLambda(1)(10)
GetLambda(2)(10)
//│ Lifted:
//│ TypingUnit {
//│   fun GetLambda = (foo,) => {if (==(foo, 1,)) then {('(' x ')',) => +(x, 5,)} else {('(' x ')',) => +(+(x, foo,), 10,)}}
//│   Code(List(GetLambda(1,)(10,)))
//│   Code(List(GetLambda(2,)(10,)))
//│ }
//│ fun GetLambda: Int -> Int -> Int
//│ Int
//│ res
//│     = 15
//│ res
//│     = 22

:nolift
class LAM1() {}
class LAM2(val foo: Int) {}
fun APPLY(lambdaObject, argTuple) =
    if lambdaObject is
        LAM1 then argTuple.0 + 5
        LAM2 then argTuple.0 + lambdaObject.foo + 10
fun GetLambda_defunc(foo) =
    if foo == 1 then
        LAM1()
    else
        LAM2(foo)
APPLY(GetLambda_defunc(1), [10]) // Gives 15
APPLY(GetLambda_defunc(2), [10]) // Gives 22
//│ Lifted:
//│ TypingUnit {
//│   class LAM1([]) {}
//│   class LAM2([val foo: Int,]) {}
//│   fun APPLY = (lambdaObject, argTuple,) => {if lambdaObject is ‹(LAM1) then +((argTuple).0, 5,); (LAM2) then +(+((argTuple).0, (lambdaObject).foo,), 10,)›}
//│   fun GetLambda_defunc = (foo,) => {if (==(foo, 1,)) then {LAM1()} else {LAM2(foo,)}}
//│   Code(List(APPLY(GetLambda_defunc(1,), [10,],)))
//│   Code(List(APPLY(GetLambda_defunc(2,), [10,],)))
//│ }
//│ class LAM1()
//│ class LAM2(foo: Int)
//│ fun APPLY: (LAM1 | LAM2, {0: Int}) -> Int
//│ fun GetLambda_defunc: Int -> (LAM1 | LAM2)
//│ Int
//│ res
//│     = 15
//│ res
//│     = 22

:nolift
fun UseLambda(foo) =
    foo(10)
val freeVar = 5
UseLambda((num) => num+1)
UseLambda((num) => num+freeVar+5)
//│ Lifted:
//│ TypingUnit {
//│   fun UseLambda = (foo,) => {foo(10,)}
//│   let freeVar = 5
//│   Code(List(UseLambda(('(' num ')',) => +(num, 1,),)))
//│   Code(List(UseLambda(('(' num ')',) => +(+(num, freeVar,), 5,),)))
//│ }
//│ fun UseLambda: forall 'a. (10 -> 'a) -> 'a
//│ val freeVar: 5
//│ Int
//│ freeVar
//│         = 5
//│ res
//│     = 11
//│ res
//│     = 20

:nolift
class LAM3() {}
class LAM4(val x: error) {}
fun APPLY2(lambdaObject, argTuple) = 
    if lambdaObject is
        LAM3 then argTuple.0 + 1
        LAM4 then argTuple.0 + lambdaObject.x + 5
val freeVar = 5
fun UseLambda_defunc(foo) =
    APPLY2(foo, [10])
UseLambda_defunc(LAM3())
UseLambda_defunc(LAM4(freeVar))
//│ Lifted:
//│ TypingUnit {
//│   class LAM3([]) {}
//│   class LAM4([val x: error,]) {}
//│   fun APPLY2 = (lambdaObject, argTuple,) => {if lambdaObject is ‹(LAM3) then +((argTuple).0, 1,); (LAM4) then +(+((argTuple).0, (lambdaObject).x,), 5,)›}
//│   let freeVar = 5
//│   fun UseLambda_defunc = (foo,) => {APPLY2(foo, [10,],)}
//│   Code(List(UseLambda_defunc(LAM3(),)))
//│   Code(List(UseLambda_defunc(LAM4(freeVar,),)))
//│ }
//│ class LAM3()
//│ class LAM4(x: error)
//│ fun APPLY2: (LAM3 | LAM4, {0: Int}) -> Int
//│ val freeVar: 5
//│ fun UseLambda_defunc: (LAM3 | LAM4) -> Int
//│ Int
//│ freeVar
//│         = 5
//│ res
//│     = 11
//│ res
//│     = 20
