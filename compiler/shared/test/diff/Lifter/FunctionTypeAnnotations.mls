:NewDefs 

// TODO: Preserve type annotations in lifting
fun foo(x) =
    (y) => x+y
foo(1)(2)
foo(2)(2)
//│ Lifted:
//│ TypingUnit {
//│   class Lambda1$2$1([x,]) {fun apply = ('(' y ')',) => +((this).x, y,)}
//│   fun foo$1 = (x,) => {{Lambda1$2$1(x,)}}
//│   Code(List(foo$1(1,)(2,)))
//│   Code(List(foo$1(2,)(2,)))
//│ }
//│ ╔══[ERROR] Class parameters currently need type annotations
//│ ║  l.5: 	    (y) => x+y
//│ ╙──     	           ^
//│ ╔══[ERROR] Parameter 'x' cannot be accessed as a field
//│ ║  l.5: 	    (y) => x+y
//│ ╙──     	           ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.6: 	foo(1)(2)
//│ ║       	    ^^^^
//│ ╟── application of type `Lambda1$2$1` is not a function
//│ ║  l.5: 	    (y) => x+y
//│ ║       	           ^
//│ ╟── but it flows into application with expected type `2 -> ?a`
//│ ║  l.6: 	foo(1)(2)
//│ ╙──     	    ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.7: 	foo(2)(2)
//│ ║       	    ^^^^
//│ ╟── application of type `Lambda1$2$1` is not a function
//│ ║  l.5: 	    (y) => x+y
//│ ║       	           ^
//│ ╟── but it flows into application with expected type `2 -> ?a`
//│ ║  l.7: 	foo(2)(2)
//│ ╙──     	    ^
//│ class Lambda1$2$1(x: error) {
//│   fun apply: Int -> Int
//│ }
//│ fun foo$1: error -> Lambda1$2$1
//│ error
//│ res
//│ Runtime error:
//│   TypeError: foo$1(...) is not a function
//│ res
//│ Runtime error:
//│   TypeError: foo$1(...) is not a function
