:NewDefs
:ParseOnly

fun foo =
  print("ok")
  print("ko")
//│ |#fun| |foo| |#=|→|print|(|"ok"|)|↵|print|(|"ko"|)|←|
//│ Parsed: {fun foo = {print("ok",); print("ko",)}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, None, [], Blk(App(Var(print), Tup(_: StrLit(ok))); App(Var(print), Tup(_: StrLit(ko))))))
//│ Lifted:
//│ TypingUnit(NuFunDef(None, foo$1, None, [], Blk(App(Var(print), Tup(_: StrLit(ok))); App(Var(print), Tup(_: StrLit(ko))))))
//│ 

class A{
  class B {}
  fun foo(x: B) = (x : B)
}
//│ |#class| |A|{|→|#class| |B| |{||}|↵|#fun| |foo|(|x|#:| |B|)| |#=| |(|x| |#:| |B|)|←|↵|}|
//│ Parsed: {class A {class B {}; fun foo = (x: B,) => '(' x : B ')'}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(), (), None, None, TypingUnit(NuTypeDef(class, B, (), Tup(), (), None, None, TypingUnit()), NuFunDef(None, foo, None, [], Lam(Tup(x: Var(B)), Bra(rcd = false, Asc(Var(x), TypeName(B))))))))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, A$1_B$2, (), Tup(_: Var(par$A$1)), (), None, None, TypingUnit()), NuTypeDef(class, A$1, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(x: Var(A$1_B$2)), Bra(rcd = false, Asc(Var(x), TypeName(A$1_B$2))))))))
//│ 

fun foo =
  let local(x) =
    class Foo {
      fun bar = x + 1
    }
    Foo().bar
  print of local(0) + local(1)
  print of (local of 0) + local of 1
  fun tmp = 1
  print of local of 0 + local of 1
  fun tmp = 2
//│ |#fun| |foo| |#=|→|#let| |local|(|x|)| |#=|→|#class| |Foo| |{|→|#fun| |bar| |#=| |x| |+| |1|←|↵|}|↵|Foo|(||)|.bar|←|↵|print| |#of| |local|(|0|)| |+| |local|(|1|)|↵|print| |#of| |(|local| |#of| |0|)| |+| |local| |#of| |1|↵|#fun| |tmp| |#=| |1|↵|print| |#of| |local| |#of| |0| |+| |local| |#of| |1|↵|#fun| |tmp| |#=| |2|←|
//│ Parsed: {fun foo = {let local = (x,) => {class Foo {fun bar = +(x, 1,)}; (Foo()).bar}; print(+(local(0,), local(1,),),); print(+('(' local(0,) ')', local(1,),),); fun tmp = 1; print(local(+(0, local(1,),),),); fun tmp = 2}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, None, [], Blk(NuFunDef(Some(false), local, None, [], Lam(Tup(_: Var(x)), Blk(NuTypeDef(class, Foo, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, bar, None, [], App(Var(+), Tup(_: Var(x), _: IntLit(1)))))); Sel(App(Var(Foo), Tup()), bar)))); App(Var(print), Tup(_: App(Var(+), Tup(_: App(Var(local), Tup(_: IntLit(0))), _: App(Var(local), Tup(_: IntLit(1))))))); App(Var(print), Tup(_: App(Var(+), Tup(_: Bra(rcd = false, App(Var(local), Tup(_: IntLit(0)))), _: App(Var(local), Tup(_: IntLit(1))))))); NuFunDef(None, tmp, None, [], IntLit(1)); App(Var(print), Tup(_: App(Var(local), Tup(_: App(Var(+), Tup(_: IntLit(0), _: App(Var(local), Tup(_: IntLit(1))))))))); NuFunDef(None, tmp, None, [], IntLit(2)))))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, Foo$1, (), Tup(_: Var(x)), (), None, None, TypingUnit(NuFunDef(None, bar, None, [], Lam(Tup(), App(Var(+), Tup(_: Sel(Var(this), x), _: IntLit(1))))))), NuFunDef(Some(false), local$3, None, [], Lam(Tup(_: Var(x)), Blk(Sel(App(Var(Foo$1), Tup(_: Var(x))), bar)))), NuFunDef(None, tmp$2, None, [], IntLit(1)), NuFunDef(None, foo$1, None, [], Blk(App(Var(print), Tup(_: App(Var(+), Tup(_: App(Var(local$3), Tup(_: IntLit(0))), _: App(Var(local$3), Tup(_: IntLit(1))))))); App(Var(print), Tup(_: App(Var(+), Tup(_: Bra(rcd = false, App(Var(local$3), Tup(_: IntLit(0)))), _: App(Var(local$3), Tup(_: IntLit(1))))))); App(Var(print), Tup(_: App(Var(local$3), Tup(_: App(Var(+), Tup(_: IntLit(0), _: App(Var(local$3), Tup(_: IntLit(1))))))))))))
//│ 

class A(y){}
let f = x => new A(0){fun bar = x+y}
f(0)
//│ |#class| |A|(|y|)|{||}|↵|#let| |f| |#=| |x| |#=>| |#new| |A|(|0|)|{|#fun| |bar| |#=| |x|+|y|}|↵|f|(|0|)|
//│ Parsed: {class A(y,) {}; let f = (x,) => new A([0,]) {fun bar = +(x, y,)}; f(0,)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(_: Var(y)), (), None, None, TypingUnit()), NuFunDef(Some(false), f, None, [], Lam(Tup(_: Var(x)), New(Some((TypeName(A),[0,])), TypingUnit(NuFunDef(None, bar, None, [], App(Var(+), Tup(_: Var(x), _: Var(y)))))))), App(Var(f), Tup(_: IntLit(0))))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, A$1, (), Tup(_: Var(y)), (), None, None, TypingUnit()), NuTypeDef(class, A$2$2, (), Tup(_: Var(y), _: Var(x)), (App(Var(A$1), Tup(_: Sel(Var(this), y)))), None, None, TypingUnit(NuFunDef(None, bar, None, [], Lam(Tup(), App(Var(+), Tup(_: Sel(Var(this), x), _: Sel(Var(this), y))))))), NuFunDef(Some(false), f$1, None, [], Lam(Tup(_: Var(x)), Blk(New(Some((TypeName(A$2$2),[0, x,])), TypingUnit())))), App(Var(f$1), Tup(_: IntLit(0))))
//│ 

class A(x){
  fun w = x
  fun foo(y) = 
    class B(z){
      fun bar = x+y+z
    }
    new B(0){
      fun bar = w+y+z
    }
}
//│ |#class| |A|(|x|)|{|→|#fun| |w| |#=| |x|↵|#fun| |foo|(|y|)| |#=| |→|#class| |B|(|z|)|{|→|#fun| |bar| |#=| |x|+|y|+|z|←|↵|}|↵|#new| |B|(|0|)|{|→|#fun| |bar| |#=| |w|+|y|+|z|←|↵|}|←|←|↵|}|
//│ Parsed: {class A(x,) {fun w = x; fun foo = (y,) => {class B(z,) {fun bar = +(+(x, y,), z,)}; new B([0,]) {fun bar = +(+(w, y,), z,)}}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(_: Var(x)), (), None, None, TypingUnit(NuFunDef(None, w, None, [], Var(x)), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(y)), Blk(NuTypeDef(class, B, (), Tup(_: Var(z)), (), None, None, TypingUnit(NuFunDef(None, bar, None, [], App(Var(+), Tup(_: App(Var(+), Tup(_: Var(x), _: Var(y))), _: Var(z)))))); New(Some((TypeName(B),[0,])), TypingUnit(NuFunDef(None, bar, None, [], App(Var(+), Tup(_: App(Var(+), Tup(_: Var(w), _: Var(y))), _: Var(z))))))))))))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, A$1_B$2, (), Tup(_: Var(par$A$1), _: Var(z), _: Var(y)), (), None, None, TypingUnit(NuFunDef(None, bar, None, [], Lam(Tup(), App(Var(+), Tup(_: App(Var(+), Tup(_: Sel(Sel(Var(this), par$A$1), x), _: Sel(Var(this), y))), _: Sel(Var(this), z))))))), NuTypeDef(class, A$1_B$1$3, (), Tup(_: Var(par$A$1), _: Var(z), _: Var(y)), (App(Var(A$1_B$2), Tup(_: Sel(Var(this), par$A$1), _: Sel(Var(this), z), _: Sel(Var(this), y)))), None, None, TypingUnit(NuFunDef(None, bar, None, [], Lam(Tup(), App(Var(+), Tup(_: App(Var(+), Tup(_: Sel(Sel(Var(this), par$A$1), w), _: Sel(Var(this), y))), _: Sel(Var(this), z))))))), NuTypeDef(class, A$1, (), Tup(_: Var(x)), (), None, None, TypingUnit(NuFunDef(None, w, None, [], Lam(Tup(), Sel(Var(this), x))), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(y)), Blk(Blk(New(Some((TypeName(A$1_B$1$3),[this, 0, y,])), TypingUnit()))))))))
//│ 

fun f(x,y,z) = 
  class A{
    fun foo = new B
    fun bar1 = x
  }
  class B{
    fun foo = new A
    fun bar2 = y
  }
  class C extends A, B {
    fun bar = bar1 + bar2
  }
//│ |#fun| |f|(|x|,|y|,|z|)| |#=| |→|#class| |A|{|→|#fun| |foo| |#=| |#new| |B|↵|#fun| |bar1| |#=| |x|←|↵|}|↵|#class| |B|{|→|#fun| |foo| |#=| |#new| |A|↵|#fun| |bar2| |#=| |y|←|↵|}|↵|#class| |C| |#extends| |A|,| |B| |{|→|#fun| |bar| |#=| |bar1| |+| |bar2|←|↵|}|←|
//│ Parsed: {fun f = (x, y, z,) => {class A {fun foo = new B([]) {}; fun bar1 = x}; class B {fun foo = new A([]) {}; fun bar2 = y}; class C: A, B {fun bar = +(bar1, bar2,)}}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, None, [], Lam(Tup(_: Var(x), _: Var(y), _: Var(z)), Blk(NuTypeDef(class, A, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, foo, None, [], New(Some((TypeName(B),[])), TypingUnit())), NuFunDef(None, bar1, None, [], Var(x)))); NuTypeDef(class, B, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, foo, None, [], New(Some((TypeName(A),[])), TypingUnit())), NuFunDef(None, bar2, None, [], Var(y)))); NuTypeDef(class, C, (), Tup(), (Var(A), Var(B)), None, None, TypingUnit(NuFunDef(None, bar, None, [], App(Var(+), Tup(_: Var(bar1), _: Var(bar2))))))))))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, A$1, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(), New(Some((TypeName(B$2),[(this).y, (this).x,])), TypingUnit()))), NuFunDef(None, bar1, None, [], Lam(Tup(), Sel(Var(this), x))))), NuTypeDef(class, B$2, (), Tup(_: Var(y), _: Var(x)), (), None, None, TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(), New(Some((TypeName(A$1),[(this).x, (this).y,])), TypingUnit()))), NuFunDef(None, bar2, None, [], Lam(Tup(), Sel(Var(this), y))))), NuTypeDef(class, C$3, (), Tup(_: Var(x), _: Var(y)), (App(Var(A$1), Tup(_: Sel(Var(this), x), _: Sel(Var(this), y))), App(Var(B$2), Tup(_: Sel(Var(this), y), _: Sel(Var(this), x)))), None, None, TypingUnit(NuFunDef(None, bar, None, [], Lam(Tup(), App(Var(+), Tup(_: Sel(Var(this), bar1), _: Sel(Var(this), bar2))))))), NuFunDef(None, f$1, None, [], Lam(Tup(_: Var(x), _: Var(y), _: Var(z)), Blk())))
//│ 

fun f(x,y,z) = 
  class C{
    class A{
      fun foo = new B
      fun bar1 = x
    }
    class B{
      fun foo = new A
      fun bar2 = y
    }
    fun boo = (new A).bar1 + B().bar2 + z
  }
//│ |#fun| |f|(|x|,|y|,|z|)| |#=| |→|#class| |C|{|→|#class| |A|{|→|#fun| |foo| |#=| |#new| |B|↵|#fun| |bar1| |#=| |x|←|↵|}|↵|#class| |B|{|→|#fun| |foo| |#=| |#new| |A|↵|#fun| |bar2| |#=| |y|←|↵|}|↵|#fun| |boo| |#=| |(|#new| |A|)|.bar1| |+| |B|(||)|.bar2| |+| |z|←|↵|}|←|
//│ Parsed: {fun f = (x, y, z,) => {class C {class A {fun foo = new B([]) {}; fun bar1 = x}; class B {fun foo = new A([]) {}; fun bar2 = y}; fun boo = +(+(('(' new A([]) {} ')').bar1, (B()).bar2,), z,)}}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, None, [], Lam(Tup(_: Var(x), _: Var(y), _: Var(z)), Blk(NuTypeDef(class, C, (), Tup(), (), None, None, TypingUnit(NuTypeDef(class, A, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, foo, None, [], New(Some((TypeName(B),[])), TypingUnit())), NuFunDef(None, bar1, None, [], Var(x)))), NuTypeDef(class, B, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, foo, None, [], New(Some((TypeName(A),[])), TypingUnit())), NuFunDef(None, bar2, None, [], Var(y)))), NuFunDef(None, boo, None, [], App(Var(+), Tup(_: App(Var(+), Tup(_: Sel(Bra(rcd = false, New(Some((TypeName(A),[])), TypingUnit())), bar1), _: Sel(App(Var(B), Tup()), bar2))), _: Var(z))))))))))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, C$1_A$2, (), Tup(_: Var(par$C$1)), (), None, None, TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(), New(Some((TypeName(C$1_B$3),[(this).par$C$1,])), TypingUnit()))), NuFunDef(None, bar1, None, [], Lam(Tup(), Sel(Sel(Var(this), par$C$1), x))))), NuTypeDef(class, C$1_B$3, (), Tup(_: Var(par$C$1)), (), None, None, TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(), New(Some((TypeName(C$1_A$2),[(this).par$C$1,])), TypingUnit()))), NuFunDef(None, bar2, None, [], Lam(Tup(), Sel(Sel(Var(this), par$C$1), y))))), NuTypeDef(class, C$1, (), Tup(_: Var(x), _: Var(y), _: Var(z)), (), None, None, TypingUnit(NuFunDef(None, boo, None, [], Lam(Tup(), App(Var(+), Tup(_: App(Var(+), Tup(_: Sel(Bra(rcd = false, New(Some((TypeName(C$1_A$2),[this,])), TypingUnit())), bar1), _: Sel(App(Var(C$1_B$3), Tup(_: Var(this))), bar2))), _: Sel(Var(this), z))))))), NuFunDef(None, f$1, None, [], Lam(Tup(_: Var(x), _: Var(y), _: Var(z)), Blk())))
//│ 

fun f(y) =
  let g(x) = x + y + 1
  class Foo(x) {
    fun h = g(x)
  }
//│ |#fun| |f|(|y|)| |#=|→|#let| |g|(|x|)| |#=| |x| |+| |y| |+| |1|↵|#class| |Foo|(|x|)| |{|→|#fun| |h| |#=| |g|(|x|)|←|↵|}|←|
//│ Parsed: {fun f = (y,) => {let g = (x,) => +(+(x, y,), 1,); class Foo(x,) {fun h = g(x,)}}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, None, [], Lam(Tup(_: Var(y)), Blk(NuFunDef(Some(false), g, None, [], Lam(Tup(_: Var(x)), App(Var(+), Tup(_: App(Var(+), Tup(_: Var(x), _: Var(y))), _: IntLit(1))))); NuTypeDef(class, Foo, (), Tup(_: Var(x)), (), None, None, TypingUnit(NuFunDef(None, h, None, [], App(Var(g), Tup(_: Var(x))))))))))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, Foo$1, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit(NuFunDef(None, h, None, [], Lam(Tup(), App(Var(g$2), Tup(_: Sel(Var(this), x), _: Var(y))))))), NuFunDef(Some(false), g$2, None, [], Lam(Tup(_: Var(x), _: Var(y)), App(Var(+), Tup(_: App(Var(+), Tup(_: Var(x), _: Var(y))), _: IntLit(1))))), NuFunDef(None, f$1, None, [], Lam(Tup(_: Var(y)), Blk())))
//│ 
  Foo(1).h
//│ | |Foo|(|1|)|.h|
//│ Parsed: {(Foo(1,)).h}
//│ Parsed:
//│ TypingUnit(Sel(App(Var(Foo), Tup(_: IntLit(1))), h))
//│ Lifted:
//│ TypingUnit(Sel(App(Var(Foo), Tup(_: IntLit(1))), h))
//│ 
  Foo(x).h
//│ | |Foo|(|x|)|.h|
//│ Parsed: {(Foo(x,)).h}
//│ Parsed:
//│ TypingUnit(Sel(App(Var(Foo), Tup(_: Var(x))), h))
//│ Lifted:
//│ TypingUnit(Sel(App(Var(Foo), Tup(_: Var(x))), h))
//│ 

fun f(x) =
  let g(x) = 
    let h(x) = x + 2
    Foo(h(x), x).bar
  class Foo(x, y) {
    fun bar = g(x)+y
  }
  Foo(x, x).bar
//│ |#fun| |f|(|x|)| |#=|→|#let| |g|(|x|)| |#=| |→|#let| |h|(|x|)| |#=| |x| |+| |2|↵|Foo|(|h|(|x|)|,| |x|)|.bar|←|↵|#class| |Foo|(|x|,| |y|)| |{|→|#fun| |bar| |#=| |g|(|x|)|+|y|←|↵|}|↵|Foo|(|x|,| |x|)|.bar|←|
//│ Parsed: {fun f = (x,) => {let g = (x,) => {let h = (x,) => +(x, 2,); (Foo(h(x,), x,)).bar}; class Foo(x, y,) {fun bar = +(g(x,), y,)}; (Foo(x, x,)).bar}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, None, [], Lam(Tup(_: Var(x)), Blk(NuFunDef(Some(false), g, None, [], Lam(Tup(_: Var(x)), Blk(NuFunDef(Some(false), h, None, [], Lam(Tup(_: Var(x)), App(Var(+), Tup(_: Var(x), _: IntLit(2))))); Sel(App(Var(Foo), Tup(_: App(Var(h), Tup(_: Var(x))), _: Var(x))), bar)))); NuTypeDef(class, Foo, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit(NuFunDef(None, bar, None, [], App(Var(+), Tup(_: App(Var(g), Tup(_: Var(x))), _: Var(y)))))); Sel(App(Var(Foo), Tup(_: Var(x), _: Var(x))), bar)))))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, Foo$1, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit(NuFunDef(None, bar, None, [], Lam(Tup(), App(Var(+), Tup(_: App(Var(g$2), Tup(_: Sel(Var(this), x))), _: Sel(Var(this), y))))))), NuFunDef(Some(false), h$3, None, [], Lam(Tup(_: Var(x)), App(Var(+), Tup(_: Var(x), _: IntLit(2))))), NuFunDef(Some(false), g$2, None, [], Lam(Tup(_: Var(x)), Blk(Sel(App(Var(Foo$1), Tup(_: App(Var(h$3), Tup(_: Var(x))), _: Var(x))), bar)))), NuFunDef(None, f$1, None, [], Lam(Tup(_: Var(x)), Blk(Sel(App(Var(Foo$1), Tup(_: Var(x), _: Var(x))), bar)))))
//│ 

class Foo(x, y) extends Bar(y, x), Baz(x + y)
//│ |#class| |Foo|(|x|,| |y|)| |#extends| |Bar|(|y|,| |x|)|,| |Baz|(|x| |+| |y|)|
//│ Parsed: {class Foo(x, y,): Bar(y, x,), Baz(+(x, y,),) {}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Foo, (), Tup(_: Var(x), _: Var(y)), (App(Var(Bar), Tup(_: Var(y), _: Var(x))), App(Var(Baz), Tup(_: App(Var(+), Tup(_: Var(x), _: Var(y)))))), None, None, TypingUnit()))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, Foo$1, (), Tup(_: Var(x), _: Var(y)), (App(Var(Bar), Tup(_: Sel(Var(this), y), _: Sel(Var(this), x))), App(Var(Baz), Tup(_: App(Var(+), Tup(_: Sel(Var(this), x), _: Sel(Var(this), y)))))), None, None, TypingUnit()))
//│ 

fun foo<T, U>(x: T): string = 
  class A(y) extends B<T>, C(y: U) {
    fun bar = this
  }
  "rua"
//│ |#fun| |foo|‹|T|,| |U|›|(|x|#:| |T|)|#:| |string| |#=| |→|#class| |A|(|y|)| |#extends| |B|‹|T|›|,| |C|(|y|#:| |U|)| |{|→|#fun| |bar| |#=| |this|←|↵|}|↵|"rua"|←|
//│ Parsed: {fun foo = (x: T,) => {class A(y,): B‹T›, C(y: U,) {fun bar = this}; "rua"} : string}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, None, [TypeName(T), TypeName(U)], Lam(Tup(x: Var(T)), Asc(Blk(NuTypeDef(class, A, (), Tup(_: Var(y)), (TyApp(Var(B), List(TypeName(T))), App(Var(C), Tup(y: Var(U)))), None, None, TypingUnit(NuFunDef(None, bar, None, [], Var(this)))); StrLit(rua)), TypeName(string)))))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, A$1, ((None,TypeName(T)), (None,TypeName(U))), Tup(_: Var(y)), (TyApp(Var(B), List(TypeName(T))), App(Var(C), Tup(y: Var(U)))), None, None, TypingUnit(NuFunDef(None, bar, None, [], Lam(Tup(), Var(this))))), NuFunDef(None, foo$1, None, [TypeName(T), TypeName(U)], Lam(Tup(x: Var(T)), Asc(Blk(StrLit(rua)), TypeName(string)))))
//│ 

class A<T>{
  class B{
    fun f = x => y => x
    fun g: T => B => T
  }
}
//│ |#class| |A|‹|T|›|{|→|#class| |B|{|→|#fun| |f| |#=| |x| |#=>| |y| |#=>| |x|↵|#fun| |g|#:| |T| |#=>| |B| |#=>| |T|←|↵|}|←|↵|}|
//│ Parsed: {class A‹T› {class B {fun f = (x,) => (y,) => x; fun g: T -> B -> T}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, ((None,TypeName(T))), Tup(), (), None, None, TypingUnit(NuTypeDef(class, B, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, f, None, [], Lam(Tup(_: Var(x)), Lam(Tup(_: Var(y)), Var(x)))), NuFunDef(None, g, None, [], PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(T))))),Function(Tuple(List((None,Field(None,TypeName(B))))),TypeName(T))))))))))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, A$1_B$2_Lambda1$1$3, (), Tup(_: Var(par$A$1_B$2), _: Var(x)), (), None, None, TypingUnit(NuFunDef(None, apply, None, [], Lam(Tup(_: Var(y)), Sel(Var(this), x))))), NuTypeDef(class, A$1_B$2, ((None,TypeName(T))), Tup(_: Var(par$A$1)), (), None, None, TypingUnit(NuFunDef(None, f, None, [], Lam(Tup(_: Var(x)), Blk(New(Some((TypeName(A$1_B$2_Lambda1$1$3),[this, x,])), TypingUnit())))), NuFunDef(None, g, None, [], PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(T))))),Function(Tuple(List((None,Field(None,TypeName(A$1_B$2))))),TypeName(T))))))), NuTypeDef(class, A$1, ((None,TypeName(T))), Tup(), (), None, None, TypingUnit()))
//│ 

class Foo<T>{
  class RectangleBox: Box<T> & { breadth: T }
  class StackedRectangleBoxes<N> : RectangleBox<T> & { size: N }
  class Bar: {any: RectangleBox => StackedRectangleBoxes}
}
//│ |#class| |Foo|‹|T|›|{|→|#class| |RectangleBox|#:| |Box|‹|T|›| |&| |{| |breadth|#:| |T| |}|↵|#class| |StackedRectangleBoxes|‹|N|›| |#:| |RectangleBox|‹|T|›| |&| |{| |size|#:| |N| |}|↵|#class| |Bar|#:| |{|any|#:| |RectangleBox| |#=>| |StackedRectangleBoxes|}|←|↵|}|
//│ Parsed: {class Foo‹T› {class RectangleBox: Box[T] & {breadth: T} {}; class StackedRectangleBoxes‹N›: RectangleBox[T] & {size: N} {}; class Bar: {any: RectangleBox -> StackedRectangleBoxes} {}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Foo, ((None,TypeName(T))), Tup(), (), None, None, TypingUnit(NuTypeDef(class, RectangleBox, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, StackedRectangleBoxes, ((None,TypeName(N))), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Bar, (), Tup(), (), None, None, TypingUnit()))))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, Foo$1_RectangleBox$2, (), Tup(_: Var(par$Foo$1)), (), None, None, TypingUnit()), NuTypeDef(class, Foo$1_StackedRectangleBoxes$3, ((None,TypeName(N))), Tup(_: Var(par$Foo$1)), (), None, None, TypingUnit()), NuTypeDef(class, Foo$1_Bar$4, (), Tup(_: Var(par$Foo$1)), (), None, None, TypingUnit()), NuTypeDef(class, Foo$1, ((None,TypeName(T))), Tup(), (), None, None, TypingUnit()))
//│ 

class Func<T, U> {
  fun apply: T => U
}
class Lambda<T, U> : Func<T, U> {}
fun ctx(a,b) =
  fun foo(f: Func, x) = 
    f.apply(x)
  foo(new Lambda{
    fun apply(x) = a+x
  }, b)
//│ |#class| |Func|‹|T|,| |U|›| |{|→|#fun| |apply|#:| |T| |#=>| |U|←|↵|}|↵|#class| |Lambda|‹|T|,| |U|›| |#:| |Func|‹|T|,| |U|›| |{||}|↵|#fun| |ctx|(|a|,|b|)| |#=|→|#fun| |foo|(|f|#:| |Func|,| |x|)| |#=| |→|f|.apply|(|x|)|←|↵|foo|(|#new| |Lambda|{|→|#fun| |apply|(|x|)| |#=| |a|+|x|←|↵|}|,| |b|)|←|
//│ Parsed: {class Func‹T, U› {fun apply: T -> U}; class Lambda‹T, U›: Func[T, U] {}; fun ctx = (a, b,) => {fun foo = (f: Func, x,) => {(f).apply(x,)}; foo(new Lambda([]) {fun apply = (x,) => +(a, x,)}, b,)}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Func, ((None,TypeName(T)), (None,TypeName(U))), Tup(), (), None, None, TypingUnit(NuFunDef(None, apply, None, [], PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(T))))),TypeName(U)))))), NuTypeDef(class, Lambda, ((None,TypeName(T)), (None,TypeName(U))), Tup(), (), None, None, TypingUnit()), NuFunDef(None, ctx, None, [], Lam(Tup(_: Var(a), _: Var(b)), Blk(NuFunDef(None, foo, None, [], Lam(Tup(f: Var(Func), _: Var(x)), Blk(App(Sel(Var(f), apply), Tup(_: Var(x)))))); App(Var(foo), Tup(_: New(Some((TypeName(Lambda),[])), TypingUnit(NuFunDef(None, apply, None, [], Lam(Tup(_: Var(x)), App(Var(+), Tup(_: Var(a), _: Var(x))))))), _: Var(b)))))))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, Func$1, ((None,TypeName(T)), (None,TypeName(U))), Tup(), (), None, None, TypingUnit(NuFunDef(None, apply, None, [], PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(T))))),TypeName(U)))))), NuTypeDef(class, Lambda$2, ((None,TypeName(T)), (None,TypeName(U))), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Lambda$3$3, (), Tup(_: Var(a)), (App(Var(Lambda$2), Tup())), None, None, TypingUnit(NuFunDef(None, apply, None, [], Lam(Tup(_: Var(x)), App(Var(+), Tup(_: Sel(Var(this), a), _: Var(x))))))), NuFunDef(None, foo$2, None, [], Lam(Tup(f: Var(Func$1), _: Var(x)), Blk(App(Sel(Var(f), apply), Tup(_: Var(x)))))), NuFunDef(None, ctx$1, None, [], Lam(Tup(_: Var(a), _: Var(b)), Blk(App(Var(foo$2), Tup(_: Blk(New(Some((TypeName(Lambda$3$3),[a,])), TypingUnit())), _: Var(b)))))))
//│ 

fun f(T) = 
  new T()
f(MyClass)
//│ |#fun| |f|(|T|)| |#=| |→|#new| |T|(||)|←|↵|f|(|MyClass|)|
//│ Parsed: {fun f = (T,) => {new T([]) {}}; f(MyClass,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, None, [], Lam(Tup(_: Var(T)), Blk(New(Some((TypeName(T),[])), TypingUnit())))), App(Var(f), Tup(_: Var(MyClass))))
//│ Lifted:
//│ Lifting failed: mlscript.codegen.CodeGenError: Cannot find type T. Class values are not supported in lifter. 
//│ 

class A {
  fun foo = 
    fun bar = foo()
    bar()
}
//│ |#class| |A| |{|→|#fun| |foo| |#=| |→|#fun| |bar| |#=| |foo|(||)|↵|bar|(||)|←|←|↵|}|
//│ Parsed: {class A {fun foo = {fun bar = foo(); bar()}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, foo, None, [], Blk(NuFunDef(None, bar, None, [], App(Var(foo), Tup())); App(Var(bar), Tup()))))))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, A$1, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(), Blk(App(Var(bar$1), Tup(_: Var(this)))))))), NuFunDef(None, bar$1, None, [], App(Sel(Var(this), foo), Tup())))
//│ 
