:NewDefs

:ge // FIXME
:nm
class A(i: Int) {
    fun get1() = i
    fun get2 = i
}
val a = A(6)
a.get1()
a.get2
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(i: Var(Int)), (), None, None, TypingUnit(NuFunDef(None, get1, None, [], Lam(Tup(), Var(i))), NuFunDef(None, get2, None, [], Var(i)))), NuFunDef(Some(false), a, None, [], App(Var(A), Tup(_: IntLit(6)))), App(Sel(Var(a), get1), Tup()), Sel(Var(a), get2))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, A$1, (), Tup(i: Var(Int)), (), None, None, TypingUnit(NuFunDef(None, get1, None, [], Lam(Tup(), Sel(Var(this), i))), NuFunDef(None, get2, None, [], Sel(Var(this), i)))), NuFunDef(Some(false), a$1, None, [], App(Var(A$1), Tup(_: IntLit(6)))), App(Sel(Var(a$1), get1), Tup()), Sel(Var(a$1), get2))
//│ TypingUnit {
//│   class A$1([i: Int,]) {fun get1 = () => (this).i; fun get2 = (this).i}
//│   let a$1 = A$1(6,)
//│   Code(List((a$1).get1()))
//│   Code(List((a$1).get2))
//│ }
//│ Mono:
//│ TypingUnit(NuTypeDef(class, A$1, (), Tup(i: Var(Int)), (), None, None, TypingUnit()), NuFunDef(None, get1$A$1, None, [], Lam(Tup(_: Var(this)), Let(false, obj, Var(this), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(A$1), IntLit(6));IfElse(Var(error)))), None)))), NuFunDef(None, get2$A$1, None, [], Lam(Tup(_: Var(this)), Let(false, obj, Var(this), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(A$1), IntLit(6));IfElse(Var(error)))), None)))), NuFunDef(None, main$$3, None, [], Lam(Tup(), Let(false, obj, Var(a$1), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(A$1), App(Var(get2$A$1), Tup(_: Var(obj))));IfElse(Var(error)))), None)))), NuFunDef(None, main$$2, None, [], Lam(Tup(), Let(false, obj, Var(a$1), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(A$1), App(Var(get1$A$1), Tup(_: Var(obj))));IfElse(Var(error)))), None)))), NuFunDef(Some(false), a$1, None, [], App(Var(A$1), Tup(_: IntLit(6)))), App(Var(main$$2), Tup()), App(Var(main$$3), Tup()))
//│ TypingUnit {
//│   class A$1([i: Int,]) {}
//│   fun get1$A$1 = (this,) => let obj = this in if obj is ‹(A$1) then 6; else error›
//│   fun get2$A$1 = (this,) => let obj = this in if obj is ‹(A$1) then 6; else error›
//│   fun main$$3 = () => let obj = a$1 in if obj is ‹(A$1) then get2$A$1(obj,); else error›
//│   fun main$$2 = () => let obj = a$1 in if obj is ‹(A$1) then get1$A$1(obj,); else error›
//│   let a$1 = A$1(6,)
//│   Code(List(main$$2()))
//│   Code(List(main$$3()))
//│ }
//│ class A$1(i: Int)
//│ fun get1$A$1: Object -> 6
//│ fun get2$A$1: Object -> 6
//│ fun main$$3: () -> 6
//│ fun main$$2: () -> 6
//│ let a$1: A$1
//│ 6
//│ Code generation encountered an error:
//│   unguarded recursive use of by-value binding a$1

:ge // FIXME
:nm
class A(i: Str) {
    fun get1() = i
    fun get2 = i
}
val a = A("6")
a.get1()
a.get2
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(i: Var(Str)), (), None, None, TypingUnit(NuFunDef(None, get1, None, [], Lam(Tup(), Var(i))), NuFunDef(None, get2, None, [], Var(i)))), NuFunDef(Some(false), a, None, [], App(Var(A), Tup(_: StrLit(6)))), App(Sel(Var(a), get1), Tup()), Sel(Var(a), get2))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, A$1, (), Tup(i: Var(Str)), (), None, None, TypingUnit(NuFunDef(None, get1, None, [], Lam(Tup(), Sel(Var(this), i))), NuFunDef(None, get2, None, [], Sel(Var(this), i)))), NuFunDef(Some(false), a$1, None, [], App(Var(A$1), Tup(_: StrLit(6)))), App(Sel(Var(a$1), get1), Tup()), Sel(Var(a$1), get2))
//│ TypingUnit {
//│   class A$1([i: Str,]) {fun get1 = () => (this).i; fun get2 = (this).i}
//│   let a$1 = A$1("6",)
//│   Code(List((a$1).get1()))
//│   Code(List((a$1).get2))
//│ }
//│ Mono:
//│ TypingUnit(NuTypeDef(class, A$1, (), Tup(i: Var(Str)), (), None, None, TypingUnit()), NuFunDef(None, get1$A$1, None, [], Lam(Tup(_: Var(this)), Let(false, obj, Var(this), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(A$1), StrLit(6));IfElse(Var(error)))), None)))), NuFunDef(None, get2$A$1, None, [], Lam(Tup(_: Var(this)), Let(false, obj, Var(this), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(A$1), StrLit(6));IfElse(Var(error)))), None)))), NuFunDef(None, main$$3, None, [], Lam(Tup(), Let(false, obj, Var(a$1), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(A$1), App(Var(get2$A$1), Tup(_: Var(obj))));IfElse(Var(error)))), None)))), NuFunDef(None, main$$2, None, [], Lam(Tup(), Let(false, obj, Var(a$1), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(A$1), App(Var(get1$A$1), Tup(_: Var(obj))));IfElse(Var(error)))), None)))), NuFunDef(Some(false), a$1, None, [], App(Var(A$1), Tup(_: StrLit(6)))), App(Var(main$$2), Tup()), App(Var(main$$3), Tup()))
//│ TypingUnit {
//│   class A$1([i: Str,]) {}
//│   fun get1$A$1 = (this,) => let obj = this in if obj is ‹(A$1) then "6"; else error›
//│   fun get2$A$1 = (this,) => let obj = this in if obj is ‹(A$1) then "6"; else error›
//│   fun main$$3 = () => let obj = a$1 in if obj is ‹(A$1) then get2$A$1(obj,); else error›
//│   fun main$$2 = () => let obj = a$1 in if obj is ‹(A$1) then get1$A$1(obj,); else error›
//│   let a$1 = A$1("6",)
//│   Code(List(main$$2()))
//│   Code(List(main$$3()))
//│ }
//│ class A$1(i: Str)
//│ fun get1$A$1: Object -> "6"
//│ fun get2$A$1: Object -> "6"
//│ fun main$$3: () -> "6"
//│ fun main$$2: () -> "6"
//│ let a$1: A$1
//│ "6"
//│ Code generation encountered an error:
//│   unguarded recursive use of by-value binding a$1

:ge //FIXME
:nm
class X()
class Y(foo: X) {
    fun get1() = foo
    fun get2 = foo
}
val a = Y(X())
a.get1()
a.get2
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, X, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Y, (), Tup(foo: Var(X)), (), None, None, TypingUnit(NuFunDef(None, get1, None, [], Lam(Tup(), Var(foo))), NuFunDef(None, get2, None, [], Var(foo)))), NuFunDef(Some(false), a, None, [], App(Var(Y), Tup(_: App(Var(X), Tup())))), App(Sel(Var(a), get1), Tup()), Sel(Var(a), get2))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, X$1, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Y$2, (), Tup(foo: Var(X$1)), (), None, None, TypingUnit(NuFunDef(None, get1, None, [], Lam(Tup(), Sel(Var(this), foo))), NuFunDef(None, get2, None, [], Sel(Var(this), foo)))), NuFunDef(Some(false), a$1, None, [], App(Var(Y$2), Tup(_: App(Var(X$1), Tup())))), App(Sel(Var(a$1), get1), Tup()), Sel(Var(a$1), get2))
//│ TypingUnit {
//│   class X$1([]) {}
//│   class Y$2([foo: X$1,]) {fun get1 = () => (this).foo; fun get2 = (this).foo}
//│   let a$1 = Y$2(X$1(),)
//│   Code(List((a$1).get1()))
//│   Code(List((a$1).get2))
//│ }
//│ Mono:
//│ TypingUnit(NuTypeDef(class, X$1, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Y$2, (), Tup(foo: Var(X$1)), (), None, None, TypingUnit()), NuFunDef(None, get1$Y$2, None, [], Lam(Tup(_: Var(this)), Let(false, obj, Var(this), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(App(Var(Y$2), Tup(_: Var(foo))), Var(foo));IfElse(Var(error)))), None)))), NuFunDef(None, main$$4, None, [], Lam(Tup(), Let(false, obj, Var(a$1), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(Y$2), App(Var(get2$Y$2), Tup(_: Var(obj))));IfElse(Var(error)))), None)))), NuFunDef(None, main$$3, None, [], Lam(Tup(), Let(false, obj, Var(a$1), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(Y$2), App(Var(get1$Y$2), Tup(_: Var(obj))));IfElse(Var(error)))), None)))), NuFunDef(None, get2$Y$2, None, [], Lam(Tup(_: Var(this)), Let(false, obj, Var(this), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(App(Var(Y$2), Tup(_: Var(foo))), Var(foo));IfElse(Var(error)))), None)))), NuFunDef(Some(false), a$1, None, [], App(Var(Y$2), Tup(_: App(Var(X$1), Tup())))), App(Var(main$$3), Tup()), App(Var(main$$4), Tup()))
//│ TypingUnit {
//│   class X$1([]) {}
//│   class Y$2([foo: X$1,]) {}
//│   fun get1$Y$2 = (this,) => let obj = this in if obj is ‹(Y$2(foo,)) then foo; else error›
//│   fun main$$4 = () => let obj = a$1 in if obj is ‹(Y$2) then get2$Y$2(obj,); else error›
//│   fun main$$3 = () => let obj = a$1 in if obj is ‹(Y$2) then get1$Y$2(obj,); else error›
//│   fun get2$Y$2 = (this,) => let obj = this in if obj is ‹(Y$2(foo,)) then foo; else error›
//│   let a$1 = Y$2(X$1(),)
//│   Code(List(main$$3()))
//│   Code(List(main$$4()))
//│ }
//│ class X$1()
//│ class Y$2(foo: X$1)
//│ fun get1$Y$2: Object -> X$1
//│ fun main$$4: () -> X$1
//│ fun main$$3: () -> X$1
//│ fun get2$Y$2: Object -> X$1
//│ let a$1: Y$2
//│ X$1
//│ Code generation encountered an error:
//│   unguarded recursive use of by-value binding a$1

:nm
class I() {}
class J() {}
class K(foo: I, bar: J) {
    fun getFoo = foo
    fun getBar = bar
}
val k = K(I(), J())
k.getFoo
k.getBar
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, I, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, J, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, K, (), Tup(foo: Var(I), bar: Var(J)), (), None, None, TypingUnit(NuFunDef(None, getFoo, None, [], Var(foo)), NuFunDef(None, getBar, None, [], Var(bar)))), NuFunDef(Some(false), k, None, [], App(Var(K), Tup(_: App(Var(I), Tup()), _: App(Var(J), Tup())))), Sel(Var(k), getFoo), Sel(Var(k), getBar))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, I$1, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, J$2, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, K$3, (), Tup(foo: Var(I$1), bar: Var(J$2)), (), None, None, TypingUnit(NuFunDef(None, getFoo, None, [], Sel(Var(this), foo)), NuFunDef(None, getBar, None, [], Sel(Var(this), bar)))), NuFunDef(Some(false), k$1, None, [], App(Var(K$3), Tup(_: App(Var(I$1), Tup()), _: App(Var(J$2), Tup())))), Sel(Var(k$1), getFoo), Sel(Var(k$1), getBar))
//│ TypingUnit {
//│   class I$1([]) {}
//│   class J$2([]) {}
//│   class K$3([foo: I$1, bar: J$2,]) {fun getFoo = (this).foo; fun getBar = (this).bar}
//│   let k$1 = K$3(I$1(), J$2(),)
//│   Code(List((k$1).getFoo))
//│   Code(List((k$1).getBar))
//│ }
//│ Mono:
//│ TypingUnit(NuTypeDef(class, I$1, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, J$2, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, K$3, (), Tup(foo: Var(I$1), bar: Var(J$2)), (), None, None, TypingUnit()), NuFunDef(None, getFoo$K$3, None, [], Lam(Tup(_: Var(this)), Let(false, obj, Var(this), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(App(Var(K$3), Tup(_: Var(foo), _: Var(bar))), Var(foo));IfElse(Var(error)))), None)))), NuFunDef(Some(false), k$1, None, [], App(Var(K$3), Tup(_: App(Var(I$1), Tup()), _: App(Var(J$2), Tup())))), NuFunDef(None, main$$5, None, [], Lam(Tup(), Let(false, obj, Var(k$1), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(K$3), App(Var(getBar$K$3), Tup(_: Var(obj))));IfElse(Var(error)))), None)))), NuFunDef(None, main$$4, None, [], Lam(Tup(), Let(false, obj, Var(k$1), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(K$3), App(Var(getFoo$K$3), Tup(_: Var(obj))));IfElse(Var(error)))), None)))), NuFunDef(None, getBar$K$3, None, [], Lam(Tup(_: Var(this)), Let(false, obj, Var(this), If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(App(Var(K$3), Tup(_: Var(foo), _: Var(bar))), Var(bar));IfElse(Var(error)))), None)))), App(Var(main$$4), Tup()), App(Var(main$$5), Tup()))
//│ TypingUnit {
//│   class I$1([]) {}
//│   class J$2([]) {}
//│   class K$3([foo: I$1, bar: J$2,]) {}
//│   fun getFoo$K$3 = (this,) => let obj = this in if obj is ‹(K$3(foo, bar,)) then foo; else error›
//│   let k$1 = K$3(I$1(), J$2(),)
//│   fun main$$5 = () => let obj = k$1 in if obj is ‹(K$3) then getBar$K$3(obj,); else error›
//│   fun main$$4 = () => let obj = k$1 in if obj is ‹(K$3) then getFoo$K$3(obj,); else error›
//│   fun getBar$K$3 = (this,) => let obj = this in if obj is ‹(K$3(foo, bar,)) then bar; else error›
//│   Code(List(main$$4()))
//│   Code(List(main$$5()))
//│ }
//│ class I$1()
//│ class J$2()
//│ class K$3(foo: I$1, bar: J$2)
//│ fun getFoo$K$3: Object -> I$1
//│ let k$1: K$3
//│ fun main$$5: () -> J$2
//│ fun main$$4: () -> I$1
//│ fun getBar$K$3: Object -> J$2
//│ J$2
//│ k$1
//│     = K$3 {}
//│ res
//│     = I$1 {}
//│ res
//│     = J$2 {}
