:NewDefs

:nm
:dd
class Foo() {fun f() = 0}
[Foo()].0.f()
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Foo, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, f, None, [], Lam(Tup(), IntLit(0))))), App(Sel(Sel(Tup(_: App(Var(Foo), Tup())), 0), f), Tup()))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, Foo$1, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, f, None, [], Lam(Tup(), IntLit(0))))), App(Sel(Sel(Tup(_: App(Var(Foo$1), Tup())), 0), f), Tup()))
//│ TypingUnit {
//│   class Foo$1([]) {fun f = () => 0}
//│   Code(List((([Foo$1(),]).0).f()))
//│ }
//│ Mono:
//│ TypingUnit(NuTypeDef(class, Foo$1, (), Tup(), (), None, None, TypingUnit()), NuFunDef(None, f$Foo$1, None, [], Lam(Tup(_: Var(this)), IntLit(0))), NuFunDef(None, main$$1, None, [], Lam(Tup(), Blk(NuFunDef(Some(false), obj, None, [], Sel(Tup(_: App(Var(Foo$1), Tup())), 0)); If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(Foo$1), App(Var(f$Foo$1), Tup(_: Var(obj)))))), None)))), App(Var(main$$1), Tup()))
//│ TypingUnit {
//│   class Foo$1([]) {}
//│   fun f$Foo$1 = (this,) => 0
//│   fun main$$1 = () => {let obj = ([Foo$1(),]).0; if obj is ‹(Foo$1) then f$Foo$1(obj,)›}
//│   Code(List(main$$1()))
//│ }
//│ Queue: HashSet(main$$1)
//│ Evaluating main$$1
//│ ╓Eval App(Sel(Sel(Tup(_: App(Var(Foo$1), Tup())), 0), f), Tup()):
//│ ║╓Eval Sel(Sel(Tup(_: App(Var(Foo$1), Tup())), 0), f):
//│ ║║╓Eval Sel(Tup(_: App(Var(Foo$1), Tup())), 0):
//│ ║║║╓Eval Tup(_: App(Var(Foo$1), Tup())):
//│ ║║║║╓Eval App(Var(Foo$1), Tup()):
//│ ║║║║║╓Eval Var(Foo$1):
//│ ║║║║║╙Result List(TypeVal(Foo$1)):
//│ ║║║║║╓Eval Tup():
//│ ║║║║║╙Result List(TupVal(Map())):
//│ ║║║║╙Result List(ObjVal(Foo$1, HashMap())):
//│ ║║║╙Result List(TupVal(Map(0 -> ObjVal(Foo$1, HashMap())))):
//│ ║║╙Result List(ObjVal(Foo$1, HashMap())):
//│ ║╙Result List(FuncVal(f$Foo$1, (), List((this,ObjVal(Foo$1, HashMap()))))):
//│ ║╓Eval Tup():
//│ ║╙Result List(TupVal(Map())):
//│ ║Apply Function f$Foo$1
//│ ║Evaluating f$Foo$1
//│ ║╓Eval IntLit(0):
//│ ║╙Result List(LiteralVal(Left(0))):
//│ ║No change in bounds of f$Foo$1
//│ ╙Result List(LiteralVal(Left(0))):
//│ No change in bounds of main$$1
//│ ========DEFUNC PHASE========
//│ Sel(Tup(_: App(Var(Foo$1), Tup())), 0)
//│ Expanding List(ObjVal(Foo$1, HashMap()))
//│ Expanding List()
//│ class Foo$1()
//│ fun f$Foo$1: anything -> 0
//│ fun main$$1: () -> 0
//│ 0
//│ res
//│     = 0

:nm
:dd
class Foo() {fun f = 0}
module x { val y = Foo() }
x.y.f
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Foo, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, f, None, [], IntLit(0)))), NuTypeDef(module, x, (), Tup(), (), None, None, TypingUnit(NuFunDef(Some(false), y, None, [], App(Var(Foo), Tup())))), Sel(Sel(Var(x), y), f))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, Foo$1, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, f, None, [], IntLit(0)))), NuTypeDef(module, x$2, (), Tup(), (), None, None, TypingUnit(NuFunDef(Some(false), y, None, [], App(Var(Foo$1), Tup())))), Sel(Sel(App(Var(x$2), Tup()), y), f))
//│ TypingUnit {
//│   class Foo$1([]) {fun f = 0}
//│   module x$2([]) {let y = Foo$1()}
//│   Code(List(((x$2()).y).f))
//│ }
//│ Mono:
//│ Cannot select from non-object value FuncVal(y$x$2, None, List((this,ObjVal(x$2, HashMap()))))
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
//│ 	at: scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)
//│ 	at: mlscript.DiffTests.$anonfun$new$29(DiffTests.scala:453)
//│ 	at: scala.Option.getOrElse(Option.scala:201)
//│ 	at: mlscript.DiffTests.rec$1(DiffTests.scala:453)
//│ 	at: mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:1080)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ 	at: org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ 	at: org.scalatest.Transformer.apply(Transformer.scala:22)
//│ 	at: org.scalatest.Transformer.apply(Transformer.scala:20)

