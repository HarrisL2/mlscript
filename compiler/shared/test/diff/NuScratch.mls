:NewDefs

let a = 5
fun foo() =
    let b = a
    b+2
foo()
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), a, None, [], IntLit(5)), NuFunDef(None, foo, None, [], Lam(Tup(), Blk(NuFunDef(Some(false), b, None, [], Var(a)); App(Var(+), Tup(_: Var(b), _: IntLit(2)))))), App(Var(foo), Tup()))
//│ Lifted:
//│ TypingUnit(NuFunDef(Some(false), a$1, None, [], IntLit(5)), NuFunDef(Some(false), b$3, None, [], Var(a$1)), NuFunDef(None, foo$2, None, [], Lam(Tup(), Blk(App(Var(+), Tup(_: Var(b$3), _: IntLit(2)))))), App(Var(foo$2), Tup()))
//│ TypingUnit {
//│   let a$1 = 5
//│   let b$3 = a$1
//│   fun foo$2 = () => {+(b$3, 2,)}
//│   Code(List(foo$2()))
//│ }
//│ let a: 5
//│ fun foo: () -> Int
//│ Int
//│ a
//│   = 5
//│ res
//│     = 7

:mono
val b =
    let a(x) = x
    a(5)
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), b, None, [], Blk(NuFunDef(Some(false), a, None, [], Lam(Tup(_: Var(x)), Var(x))); App(Var(a), Tup(_: IntLit(5))))))
//│ Lifted:
//│ TypingUnit(NuFunDef(Some(false), a$2, None, [], Lam(Tup(_: Var(x)), Var(x))), NuFunDef(Some(false), b$1, None, [], Blk(App(Var(a$2), Tup(_: IntLit(5))))))
//│ TypingUnit {let a$2 = (x,) => x; let b$1 = {a$2(5,)}}
//│ Mono:
//│ 
//│ Defunc result: 
//│ let a$2(x) =
//│   x
//│ let b$1 =
//│   a$2(#5)
//│ val b: 5
//│ b
//│   = 5

:mono
fun lambda(num) = (num2) => num+num2
lambda(1)(2)
//│ Parsed:
//│ TypingUnit(NuFunDef(None, lambda, None, [], Lam(Tup(_: Var(num)), Lam(Tup(_: Bra(rcd = false, Var(num2))), App(Var(+), Tup(_: Var(num), _: Var(num2)))))), App(App(Var(lambda), Tup(_: IntLit(1))), Tup(_: IntLit(2))))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, Lambda1$2$1, (), Tup(_: Var(num)), (), None, None, TypingUnit(NuFunDef(None, apply, None, [], Lam(Tup(_: Bra(rcd = false, Var(num2))), App(Var(+), Tup(_: Sel(Var(this), num), _: Var(num2))))))), NuFunDef(None, lambda$1, None, [], Lam(Tup(_: Var(num)), Blk(New(Some((TypeName(Lambda1$2$1),[num,])), TypingUnit())))), App(App(Var(lambda$1), Tup(_: IntLit(1))), Tup(_: IntLit(2))))
//│ TypingUnit {
//│   class Lambda1$2$1([num,]) {fun apply = ('(' num2 ')',) => +((this).num, num2,)}
//│   fun lambda$1 = (num,) => {new Lambda1$2$1([num,]) {}}
//│   Code(List(lambda$1(1,)(2,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ class Lambda1$2$1(num) {
//│ }
//│ fun apply$Lambda1$2$1(this, num2) =
//│   +(this.num, num2)
//│ fun lambda$1(num) =
//│   new Lambda1$2$1 (num) 
//│ fun main$$2() =
//│   lambda$1(#1) match {case obj: Lambda1$2$1 => apply$Lambda1$2$1(obj, #2)}
//│ main$$2()
//│ fun lambda: Int -> Int -> Int
//│ Int
//│ res
//│     = 3

//:mono
//class G() {
//    val x = 5
//}
//(new G).x

//:mono
//:rc
//class M(num: Int) {
//    fun get() = num
//}
//(new M(6)).get()

fun foo(num) = num
fun bar(num: Int) = num
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(_: Var(num)), Var(num))), NuFunDef(None, bar, None, [], Lam(Tup(num: Var(Int)), Var(num))))
//│ Lifted:
//│ TypingUnit(NuFunDef(None, foo$2, None, [], Lam(Tup(_: Var(num)), Var(num))), NuFunDef(None, bar$1, None, [], Lam(Tup(num: Var(Int)), Var(num))))
//│ TypingUnit {
//│   fun foo$2 = (num,) => num
//│   fun bar$1 = (num: Int,) => num
//│ }
//│ fun foo: forall 'a. 'a -> 'a
//│ fun bar: (num: Int) -> Int

:js
class X {}
class Y() {}
class Z(num: Int) {}
class W(val num: Int) {}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, X, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Y, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Z, (), Tup(num: Var(Int)), (), None, None, TypingUnit()), NuTypeDef(class, W, (), Tup(num: Var(Int)), (), None, None, TypingUnit()))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, X$1, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Y$2, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Z$3, (), Tup(num: Var(Int)), (), None, None, TypingUnit()), NuTypeDef(class, W$4, (), Tup(num: Var(Int)), (), None, None, TypingUnit()))
//│ TypingUnit {
//│   class X$1([]) {}
//│   class Y$2([]) {}
//│   class Z$3([num: Int,]) {}
//│   class W$4([val num: Int,]) {}
//│ }
//│ class X {
//│   constructor()
//│ }
//│ class Y()
//│ class Z(num: Int)
//│ class W(num: Int)
//│ // Prelude
//│ class TypingUnit4 {
//│   #X;
//│   #Y;
//│   #Z;
//│   #W;
//│   constructor() {
//│   }
//│   get X() {
//│     const qualifier = this;
//│     if (this.#X === undefined) {
//│       class X {};
//│       this.#X = X;
//│     }
//│     return this.#X;
//│   }
//│   get Y() {
//│     const qualifier = this;
//│     if (this.#Y === undefined) {
//│       class Y {
//│         constructor() {
//│         }
//│       static
//│         unapply(x) {
//│           return [];
//│         }
//│       };
//│       this.#Y = (() => Object.freeze(new Y()));
//│       this.#Y.class = Y;
//│       this.#Y.unapply = Y.unapply;
//│     }
//│     return this.#Y;
//│   }
//│   get Z() {
//│     const qualifier = this;
//│     if (this.#Z === undefined) {
//│       class Z {
//│         #num;
//│         constructor(num) {
//│           this.#num = num;
//│         }
//│       static
//│         unapply(x) {
//│           return [x.#num];
//│         }
//│       };
//│       this.#Z = ((num) => Object.freeze(new Z(num)));
//│       this.#Z.class = Z;
//│       this.#Z.unapply = Z.unapply;
//│     }
//│     return this.#Z;
//│   }
//│   get W() {
//│     const qualifier = this;
//│     if (this.#W === undefined) {
//│       class W {
//│         #num;
//│         get num() { return this.#num; }
//│         constructor(num) {
//│           this.#num = num;
//│         }
//│       static
//│         unapply(x) {
//│           return [x.#num];
//│         }
//│       };
//│       this.#W = ((num) => Object.freeze(new W(num)));
//│       this.#W.class = W;
//│       this.#W.unapply = W.unapply;
//│     }
//│     return this.#W;
//│   }
//│ }
//│ const typing_unit4 = new TypingUnit4;
//│ globalThis.X = typing_unit4.X;
//│ globalThis.Y = typing_unit4.Y;
//│ globalThis.Z = typing_unit4.Z;
//│ globalThis.W = typing_unit4.W;
//│ // End of generated code
