:NewDefs

:pd
:p
:nolift
val a = {
    number: 6
}
a.number
//│ |#val| |a| |#=| |{|→|number|#:| |6|←|↵|}|↵|a|.number|
//│ AST: TypingUnit(List(NuFunDef(Some(false),Var(a),None,List(),Left(Bra(true,Rcd(List((Var(number),Fld(_,IntLit(6)))))))), Sel(Var(a),Var(number))))
//│ TypingUnit(List(NuFunDef(Some(false),Var(a),None,List(),Left(Bra(true,Rcd(List((Var(number),Fld(_,IntLit(6)))))))), Sel(Var(a),Var(number))))
//│ 
//│ Polydef:
//│ Map(Bra(true,Rcd(List((Var(number),Fld(_,IntLit(6)))))) -> 6, Rcd(List((Var(number),Fld(_,IntLit(6))))) -> 4, Sel(Var(a),Var(number)) -> 8, Var(a) -> 10, IntLit(6) -> 2)
//│ HashMap(2 -> Strat(ProdPrim(Int)), 4 -> Strat(ProdObj(None,List((Var(number),Strat(ProdPrim(Int)))))), 6 -> Strat(ProdObj(None,List((Var(number),Strat(ProdPrim(Int)))))), 8 -> Strat(ProdVar(1,7_selres)), 10 -> Strat(ProdVar(0,a)))
//│ TypeVars: 0 -> a
//│ 1 -> 7_selres
//│ Upper bounds: 0 -> List((Path(List(Normal(Var(a)))),Strat(ConsObj(None,List((Var(number),Strat(ConsVar(1,7_selres))))))))
//│ 1 -> List((Path(List()),Strat(NoCons())))
//│ Lower bounds: 0 -> List((Path(List()),Strat(ProdObj(None,List((Var(number),Strat(ProdPrim(Int))))))))
//│ 1 -> List((Path(List()),Strat(ProdPrim(Int))))
//│ Polydef end
//│ 
//│ Parsed: let a = '{' {number: 6} '}'; (a).number;
//│ val a: {number: 6}
//│ 6
//│ a
//│   = { number: 6 }
//│ res
//│     = 6


:pd
//:dpd
:nolift
:p
class X() {
    val inner = 6
}
val b = X()
b.inner
//│ |#class| |X|(||)| |{|→|#val| |inner| |#=| |6|←|↵|}|↵|#val| |b| |#=| |X|(||)|↵|b|.inner|
//│ AST: TypingUnit(List(NuTypeDef(Cls,TypeName(X),List(),Some(Tup(List())),None,None,List(),None,None,TypingUnit(List(NuFunDef(Some(false),Var(inner),None,List(),Left(IntLit(6)))))), NuFunDef(Some(false),Var(b),None,List(),Left(App(Var(X),Tup(List())))), Sel(Var(b),Var(inner))))
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(X),List(),Some(Tup(List())),None,None,List(),None,None,TypingUnit(List(NuFunDef(Some(false),Var(inner),None,List(),Left(IntLit(6)))))), NuFunDef(Some(false),Var(b),None,List(),Left(App(Var(X),Tup(List())))), Sel(Var(b),Var(inner))))
//│ 
//│ Polydef:
//│ Map(Sel(Var(b),Var(inner)) -> 10, Tup(List()) -> 6, Var(b) -> 12, App(Var(X),Tup(List())) -> 8, IntLit(6) -> 2, Var(X) -> 4)
//│ HashMap(2 -> Strat(ProdPrim(Int)), 4 -> Strat(ProdObj(Some(Var(X)),List((Var(inner),Strat(ProdVar(1,inner)))))), 6 -> Strat(ProdTup(List())), 8 -> Strat(ProdObj(Some(Var(X)),List((Var(inner),Strat(ProdVar(1,inner)))))), 10 -> Strat(ProdVar(2,9_selres)), 12 -> Strat(ProdVar(0,b)))
//│ TypeVars: 0 -> b
//│ 1 -> inner
//│ 2 -> 9_selres
//│ Upper bounds: 0 -> List((Path(List(Normal(Var(b)))),Strat(ConsObj(None,List((Var(inner),Strat(ConsVar(2,9_selres))))))))
//│ 1 -> List((Path(List()),Strat(ConsVar(2,9_selres))))
//│ 2 -> List((Path(List()),Strat(NoCons())))
//│ Lower bounds: 0 -> List((Path(List()),Strat(ProdObj(Some(Var(X)),List((Var(inner),Strat(ProdVar(1,inner))))))))
//│ 1 -> List((Path(List()),Strat(ProdPrim(Int))))
//│ 2 -> List((Path(List()),Strat(ProdPrim(Int))))
//│ Polydef end
//│ 
//│ Parsed: class X() {let inner = 6}; let b = X(); (b).inner;
//│ class X() {
//│   val inner: 6
//│ }
//│ val b: X
//│ 6
//│ b
//│   = X {}
//│ res
//│     = 6
