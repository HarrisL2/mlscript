:NewDefs

:mono
val b =
    let a(x) = x
    a(5)
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), b, None, [], Blk(NuFunDef(Some(false), a, None, [], Lam(Tup(_: Var(x)), Var(x))); App(Var(a), Tup(_: IntLit(5))))))
//│ Lifted:
//│ TypingUnit(NuFunDef(Some(false), a$2, None, [], Lam(Tup(_: Var(x)), Var(x))), NuFunDef(Some(false), b$1, None, [], Blk(App(Var(a$2), Tup(_: IntLit(5))))))
//│ TypingUnit {let a$2 = (x,) => x; let b$1 = {a$2(5,)}}
//│ Mono:
//│ 
//│ Defunc result: 
//│ let a$2(x) =
//│   x
//│ let b$1 =
//│   a$2(#5)
//│ val b: 5
//│ b
//│   = 5

:mono
fun lambda(num) = (num2) => num+num2
lambda(1)(2)
//│ Parsed:
//│ TypingUnit(NuFunDef(None, lambda, None, [], Lam(Tup(_: Var(num)), Lam(Tup(_: Bra(rcd = false, Var(num2))), App(Var(+), Tup(_: Var(num), _: Var(num2)))))), App(App(Var(lambda), Tup(_: IntLit(1))), Tup(_: IntLit(2))))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, Lambda1$2$1, (), Tup(_: Var(num)), (), None, None, TypingUnit(NuFunDef(None, apply, None, [], Lam(Tup(_: Bra(rcd = false, Var(num2))), App(Var(+), Tup(_: Sel(Var(this), num), _: Var(num2))))))), NuFunDef(None, lambda$1, None, [], Lam(Tup(_: Var(num)), Blk(New(Some((TypeName(Lambda1$2$1),[num,])), TypingUnit())))), App(App(Var(lambda$1), Tup(_: IntLit(1))), Tup(_: IntLit(2))))
//│ TypingUnit {
//│   class Lambda1$2$1([num,]) {fun apply = ('(' num2 ')',) => +((this).num, num2,)}
//│   fun lambda$1 = (num,) => {new Lambda1$2$1([num,]) {}}
//│   Code(List(lambda$1(1,)(2,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ class Lambda1$2$1(num) {
//│ }
//│ fun apply$Lambda1$2$1(this, num2) =
//│   +(this.num, num2)
//│ fun lambda$1(num) =
//│   new Lambda1$2$1 (num) 
//│ fun main$$2() =
//│   lambda$1(#1) match {case obj: Lambda1$2$1 => apply$Lambda1$2$1(obj, #2)}
//│ main$$2()
//│ fun lambda: Int -> Int -> Int
//│ Int
//│ res
//│     = 3

:mono
class G() {
    val x = 5
}
(new G).x
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, G, (), Tup(), (), None, None, TypingUnit(NuFunDef(Some(false), x, None, [], IntLit(5)))), Sel(Bra(rcd = false, NuNew(Var(G))), x))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, G$1, (), Tup(), (), None, None, TypingUnit(NuFunDef(Some(false), x, None, [], IntLit(5)))), Sel(Bra(rcd = false, New(Some((TypeName(G$1),[])), TypingUnit())), x))
//│ TypingUnit {
//│   class G$1([]) {let x = 5}
//│   Code(List(('(' new G$1([]) {} ')').x))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ class G$1() {
//│ }
//│ let x$G$1(this) =
//│   #5
//│ fun main$$1() =
//│   new G$1 () .x
//│ main$$1()
//│ class G() {
//│   val x: 5
//│ }
//│ 5
//│ res
//│ Runtime error:
//│   TypeError: G.class.x is not a constructor

:mono
:rc
class M(num: Int) {
    fun get() = num
}
(new M(6)).get()
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, M, (), Tup(num: Var(Int)), (), None, None, TypingUnit(NuFunDef(None, get, None, [], Lam(Tup(), Var(num))))), App(Sel(Bra(rcd = false, App(NuNew(Var(M)), Tup(_: IntLit(6)))), get), Tup()))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, M$1, (), Tup(num: Var(Int)), (), None, None, TypingUnit(NuFunDef(None, get, None, [], Lam(Tup(), Sel(Var(this), num))))), App(Sel(Bra(rcd = false, New(Some((TypeName(M$1),[6,])), TypingUnit())), get), Tup()))
//│ TypingUnit {
//│   class M$1([num: Int,]) {fun get = () => (this).num}
//│   Code(List(('(' new M$1([6,]) {} ')').get()))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ class M$1(num) {
//│ }
//│ fun get$M$1(this) =
//│   this.num
//│ fun main$$1() =
//│   new M$1 (#6)  match {case obj: M$1 => get$M$1(obj)}
//│ main$$1()
//│ ╔══[ERROR] Currently unsupported `new` syntax
//│ ╙──
//│ ╔══[ERROR] identifier not found: obj
//│ ╙──
//│ class M$1(num: Int)
//│ fun get$M$1: forall 'num. {num: 'num} -> 'num
//│ fun main$$1: () -> error
//│ error
//│ Code generation encountered an error:
//│   unresolved symbol obj

fun foo(num) = num
fun bar(num: Int) = num
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(_: Var(num)), Var(num))), NuFunDef(None, bar, None, [], Lam(Tup(num: Var(Int)), Var(num))))
//│ Lifted:
//│ TypingUnit(NuFunDef(None, foo$2, None, [], Lam(Tup(_: Var(num)), Var(num))), NuFunDef(None, bar$1, None, [], Lam(Tup(num: Var(Int)), Var(num))))
//│ TypingUnit {
//│   fun foo$2 = (num,) => num
//│   fun bar$1 = (num: Int,) => num
//│ }
//│ fun foo: forall 'a. 'a -> 'a
//│ fun bar: (num: Int) -> Int

:js
class X {}
class Y() {}
class Z(num: Int) {}
class W(val num: Int) {}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, X, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Y, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Z, (), Tup(num: Var(Int)), (), None, None, TypingUnit()), NuTypeDef(class, W, (), Tup(num: Var(Int)), (), None, None, TypingUnit()))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, X$1, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Y$2, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Z$3, (), Tup(num: Var(Int)), (), None, None, TypingUnit()), NuTypeDef(class, W$4, (), Tup(num: Var(Int)), (), None, None, TypingUnit()))
//│ TypingUnit {
//│   class X$1([]) {}
//│   class Y$2([]) {}
//│   class Z$3([num: Int,]) {}
//│   class W$4([val num: Int,]) {}
//│ }
//│ class X {
//│   constructor()
//│ }
//│ class Y()
//│ class Z(num: Int)
//│ class W(num: Int)
//│ // Prelude
//│ class TypingUnit5 {
//│   #X;
//│   #Y;
//│   #Z;
//│   #W;
//│   constructor() {
//│   }
//│   get X() {
//│     const qualifier = this;
//│     if (this.#X === undefined) {
//│       class X {};
//│       this.#X = X;
//│     }
//│     return this.#X;
//│   }
//│   get Y() {
//│     const qualifier = this;
//│     if (this.#Y === undefined) {
//│       class Y {
//│         constructor() {
//│         }
//│       static
//│         unapply(x) {
//│           return [];
//│         }
//│       };
//│       this.#Y = (() => Object.freeze(new Y()));
//│       this.#Y.class = Y;
//│       this.#Y.unapply = Y.unapply;
//│     }
//│     return this.#Y;
//│   }
//│   get Z() {
//│     const qualifier = this;
//│     if (this.#Z === undefined) {
//│       class Z {
//│         #num;
//│         constructor(num) {
//│           this.#num = num;
//│         }
//│       static
//│         unapply(x) {
//│           return [x.#num];
//│         }
//│       };
//│       this.#Z = ((num) => Object.freeze(new Z(num)));
//│       this.#Z.class = Z;
//│       this.#Z.unapply = Z.unapply;
//│     }
//│     return this.#Z;
//│   }
//│   get W() {
//│     const qualifier = this;
//│     if (this.#W === undefined) {
//│       class W {
//│         #num;
//│         get num() { return this.#num; }
//│         constructor(num) {
//│           this.#num = num;
//│         }
//│       static
//│         unapply(x) {
//│           return [x.#num];
//│         }
//│       };
//│       this.#W = ((num) => Object.freeze(new W(num)));
//│       this.#W.class = W;
//│       this.#W.unapply = W.unapply;
//│     }
//│     return this.#W;
//│   }
//│ }
//│ const typing_unit5 = new TypingUnit5;
//│ globalThis.X = typing_unit5.X;
//│ globalThis.Y = typing_unit5.Y;
//│ globalThis.Z = typing_unit5.Z;
//│ globalThis.W = typing_unit5.W;
//│ // End of generated code
