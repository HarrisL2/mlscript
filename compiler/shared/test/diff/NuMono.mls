:NewDefs


:nm
class A() {
    val num() = 0
}
class B() {
    val num() = 1
}
fun foo(num: Int) = if false then new A() else new B()
foo(10).num()
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(), (), None, None, TypingUnit(NuFunDef(Some(false), num, None, [], Lam(Tup(), IntLit(0))))), NuTypeDef(class, B, (), Tup(), (), None, None, TypingUnit(NuFunDef(Some(false), num, None, [], Lam(Tup(), IntLit(1))))), NuFunDef(None, foo, None, [], Lam(Tup(num: Var(Int)), If(IfThen(Var(false), New(Some((TypeName(A),[])), TypingUnit())), Some(New(Some((TypeName(B),[])), TypingUnit()))))), App(Sel(App(Var(foo), Tup(_: IntLit(10))), num), Tup()))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, A$1, (), Tup(), (), None, None, TypingUnit(NuFunDef(Some(false), num, None, [], Lam(Tup(), IntLit(0))))), NuTypeDef(class, B$2, (), Tup(), (), None, None, TypingUnit(NuFunDef(Some(false), num, None, [], Lam(Tup(), IntLit(1))))), NuFunDef(None, foo$1, None, [], Lam(Tup(num: Var(Int)), If(IfThen(Var(false), New(Some((TypeName(A$1),[])), TypingUnit())), Some(New(Some((TypeName(B$2),[])), TypingUnit()))))), App(Sel(App(Var(foo$1), Tup(_: IntLit(10))), num), Tup()))
//│ TypingUnit {
//│   class A$1([]) {let num = () => 0}
//│   class B$2([]) {let num = () => 1}
//│   fun foo$1 = (num: Int,) => if (false) then new A$1([]) {} else new B$2([]) {}
//│   Code(List((foo$1(10,)).num()))
//│ }
//│ Mono:
//│ TypingUnit(NuTypeDef(class, B$2, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, A$1, (), Tup(), (), None, None, TypingUnit()), NuFunDef(None, foo$1, None, [], Lam(Tup(num: Var(Int)), If(IfThen(Var(false), New(Some((TypeName(A$1),[])), TypingUnit())), Some(New(Some((TypeName(B$2),[])), TypingUnit()))))), NuFunDef(Some(false), num$A$1, None, [], Lam(Tup(_: Var(this)), IntLit(0))), NuFunDef(Some(false), num$B$2, None, [], Lam(Tup(_: Var(this)), IntLit(1))), NuFunDef(None, main$$3, None, [], Lam(Tup(), Blk(NuFunDef(Some(false), obj, None, [], App(Var(foo$1), Tup(_: IntLit(10)))); If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(B$2), App(Var(num$B$2), Tup(_: Var(obj))));IfThen(Var(A$1), App(Var(num$A$1), Tup(_: Var(obj)))))), None)))), App(Var(main$$3), Tup()))
//│ TypingUnit {
//│   class B$2([]) {}
//│   class A$1([]) {}
//│   fun foo$1 = (num: Int,) => if (false) then new A$1([]) {} else new B$2([]) {}
//│   let num$A$1 = (this,) => 0
//│   let num$B$2 = (this,) => 1
//│   fun main$$3 = () => {let obj = foo$1(10,); if obj is ‹(B$2) then num$B$2(obj,); (A$1) then num$A$1(obj,)›}
//│   Code(List(main$$3()))
//│ }
//│ class B$2()
//│ class A$1()
//│ fun foo$1: (num: Int) -> (A$1 | B$2)
//│ let num$A$1: anything -> 0
//│ let num$B$2: anything -> 1
//│ fun main$$3: () -> (0 | 1)
//│ 0 | 1
//│ num$A$1
//│         = [Function: num$A$1]
//│ num$B$2
//│         = [Function: num$B$2]
//│ res
//│     = 1


:nm
class A() {
    val num() = 0
}
class B() {
    val num() = 1
}
fun foo(num: Int) = if false then A() else B()
foo(10).num()
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(), (), None, None, TypingUnit(NuFunDef(Some(false), num, None, [], Lam(Tup(), IntLit(0))))), NuTypeDef(class, B, (), Tup(), (), None, None, TypingUnit(NuFunDef(Some(false), num, None, [], Lam(Tup(), IntLit(1))))), NuFunDef(None, foo, None, [], Lam(Tup(num: Var(Int)), If(IfThen(Var(false), App(Var(A), Tup())), Some(App(Var(B), Tup()))))), App(Sel(App(Var(foo), Tup(_: IntLit(10))), num), Tup()))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, A$1, (), Tup(), (), None, None, TypingUnit(NuFunDef(Some(false), num, None, [], Lam(Tup(), IntLit(0))))), NuTypeDef(class, B$2, (), Tup(), (), None, None, TypingUnit(NuFunDef(Some(false), num, None, [], Lam(Tup(), IntLit(1))))), NuFunDef(None, foo$1, None, [], Lam(Tup(num: Var(Int)), If(IfThen(Var(false), App(Var(A$1), Tup())), Some(App(Var(B$2), Tup()))))), App(Sel(App(Var(foo$1), Tup(_: IntLit(10))), num), Tup()))
//│ TypingUnit {
//│   class A$1([]) {let num = () => 0}
//│   class B$2([]) {let num = () => 1}
//│   fun foo$1 = (num: Int,) => if (false) then A$1() else B$2()
//│   Code(List((foo$1(10,)).num()))
//│ }
//│ Mono:
//│ TypingUnit(NuTypeDef(class, B$2, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, A$1, (), Tup(), (), None, None, TypingUnit()), NuFunDef(None, foo$1, None, [], Lam(Tup(num: Var(Int)), If(IfThen(Var(false), App(Var(A$1), Tup())), Some(App(Var(B$2), Tup()))))), NuFunDef(Some(false), num$A$1, None, [], Lam(Tup(_: Var(this)), IntLit(0))), NuFunDef(Some(false), num$B$2, None, [], Lam(Tup(_: Var(this)), IntLit(1))), NuFunDef(None, main$$3, None, [], Lam(Tup(), Blk(NuFunDef(Some(false), obj, None, [], App(Var(foo$1), Tup(_: IntLit(10)))); If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(B$2), App(Var(num$B$2), Tup(_: Var(obj))));IfThen(Var(A$1), App(Var(num$A$1), Tup(_: Var(obj)))))), None)))), App(Var(main$$3), Tup()))
//│ TypingUnit {
//│   class B$2([]) {}
//│   class A$1([]) {}
//│   fun foo$1 = (num: Int,) => if (false) then A$1() else B$2()
//│   let num$A$1 = (this,) => 0
//│   let num$B$2 = (this,) => 1
//│   fun main$$3 = () => {let obj = foo$1(10,); if obj is ‹(B$2) then num$B$2(obj,); (A$1) then num$A$1(obj,)›}
//│   Code(List(main$$3()))
//│ }
//│ class B$2()
//│ class A$1()
//│ fun foo$1: (num: Int) -> (A$1 | B$2)
//│ let num$A$1: anything -> 0
//│ let num$B$2: anything -> 1
//│ fun main$$3: () -> (0 | 1)
//│ 0 | 1
//│ num$A$1
//│         = [Function: num$A$11]
//│ num$B$2
//│         = [Function: num$B$21]
//│ res
//│     = 1


:nm
class A(val num1: Int, val num2: Int) {
    fun foo() = num1-num2
}
class B(val num1: Int, val num2: Int) {
    fun foo() = num1+num2
}
fun foo(num: Int) = if num > 5 then new A(10,6) else B(8,7)
foo(10).foo()
foo(0).foo()
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(num1: Var(Int), num2: Var(Int)), (), None, None, TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(), App(Var(-), Tup(_: Var(num1), _: Var(num2))))))), NuTypeDef(class, B, (), Tup(num1: Var(Int), num2: Var(Int)), (), None, None, TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(), App(Var(+), Tup(_: Var(num1), _: Var(num2))))))), NuFunDef(None, foo, None, [], Lam(Tup(num: Var(Int)), If(IfThen(App(Var(>), Tup(_: Var(num), _: IntLit(5))), New(Some((TypeName(A),[10, 6,])), TypingUnit())), Some(App(Var(B), Tup(_: IntLit(8), _: IntLit(7))))))), App(Sel(App(Var(foo), Tup(_: IntLit(10))), foo), Tup()), App(Sel(App(Var(foo), Tup(_: IntLit(0))), foo), Tup()))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, A$1, (), Tup(num1: Var(Int), num2: Var(Int)), (), None, None, TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(), App(Var(-), Tup(_: Sel(Var(this), num1), _: Sel(Var(this), num2))))))), NuTypeDef(class, B$2, (), Tup(num1: Var(Int), num2: Var(Int)), (), None, None, TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(), App(Var(+), Tup(_: Sel(Var(this), num1), _: Sel(Var(this), num2))))))), NuFunDef(None, foo$1, None, [], Lam(Tup(num: Var(Int)), If(IfThen(App(Var(>), Tup(_: Var(num), _: IntLit(5))), New(Some((TypeName(A$1),[10, 6,])), TypingUnit())), Some(App(Var(B$2), Tup(_: IntLit(8), _: IntLit(7))))))), App(Sel(App(Var(foo$1), Tup(_: IntLit(10))), foo), Tup()), App(Sel(App(Var(foo$1), Tup(_: IntLit(0))), foo), Tup()))
//│ TypingUnit {
//│   class A$1([val num1: Int, val num2: Int,]) {fun foo = () => -((this).num1, (this).num2,)}
//│   class B$2([val num1: Int, val num2: Int,]) {fun foo = () => +((this).num1, (this).num2,)}
//│   fun foo$1 = (num: Int,) => if (>(num, 5,)) then new A$1([10, 6,]) {} else B$2(8, 7,)
//│   Code(List((foo$1(10,)).foo()))
//│   Code(List((foo$1(0,)).foo()))
//│ }
//│ Mono:
//│ TypingUnit(NuTypeDef(class, B$2, (), Tup(num1: Var(Int), num2: Var(Int)), (), None, None, TypingUnit()), NuTypeDef(class, A$1, (), Tup(num1: Var(Int), num2: Var(Int)), (), None, None, TypingUnit()), NuFunDef(None, foo$B$2, None, [], Lam(Tup(_: Var(this)), App(Var(+), Tup(_: Sel(Var(this), num1), _: Sel(Var(this), num2))))), NuFunDef(None, foo$1, None, [], Lam(Tup(num: Var(Int)), If(IfThen(App(Var(>), Tup(_: Var(num), _: IntLit(5))), New(Some((TypeName(A$1),[10, 6,])), TypingUnit())), Some(App(Var(B$2), Tup(_: IntLit(8), _: IntLit(7))))))), NuFunDef(None, foo$A$1, None, [], Lam(Tup(_: Var(this)), App(Var(-), Tup(_: Sel(Var(this), num1), _: Sel(Var(this), num2))))), NuFunDef(None, main$$4, None, [], Lam(Tup(), Blk(NuFunDef(Some(false), obj, None, [], App(Var(foo$1), Tup(_: IntLit(0)))); If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(B$2), App(Var(foo$B$2), Tup(_: Var(obj))));IfThen(Var(A$1), App(Var(foo$A$1), Tup(_: Var(obj)))))), None)))), NuFunDef(None, main$$3, None, [], Lam(Tup(), Blk(NuFunDef(Some(false), obj, None, [], App(Var(foo$1), Tup(_: IntLit(10)))); If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(B$2), App(Var(foo$B$2), Tup(_: Var(obj))));IfThen(Var(A$1), App(Var(foo$A$1), Tup(_: Var(obj)))))), None)))), App(Var(main$$3), Tup()), App(Var(main$$4), Tup()))
//│ TypingUnit {
//│   class B$2([val num1: Int, val num2: Int,]) {}
//│   class A$1([val num1: Int, val num2: Int,]) {}
//│   fun foo$B$2 = (this,) => +((this).num1, (this).num2,)
//│   fun foo$1 = (num: Int,) => if (>(num, 5,)) then new A$1([10, 6,]) {} else B$2(8, 7,)
//│   fun foo$A$1 = (this,) => -((this).num1, (this).num2,)
//│   fun main$$4 = () => {let obj = foo$1(0,); if obj is ‹(B$2) then foo$B$2(obj,); (A$1) then foo$A$1(obj,)›}
//│   fun main$$3 = () => {let obj = foo$1(10,); if obj is ‹(B$2) then foo$B$2(obj,); (A$1) then foo$A$1(obj,)›}
//│   Code(List(main$$3()))
//│   Code(List(main$$4()))
//│ }
//│ class B$2(num1: Int, num2: Int)
//│ class A$1(num1: Int, num2: Int)
//│ fun foo$B$2: {num1: Int, num2: Int} -> Int
//│ fun foo$1: (num: Int) -> (A$1 | B$2)
//│ fun foo$A$1: {num1: Int, num2: Int} -> Int
//│ fun main$$4: () -> Int
//│ fun main$$3: () -> Int
//│ Int
//│ res
//│     = 4
//│ res
//│     = 15

class A() {
    val num() = 0
}
class B() {
    val num() = 1
}
fun A_num(obj) = 0
fun B_num(obj) = 1
fun foo(num) = if true then new A() else new B()
fun main3() = 
    let obj = foo(10)
    if obj is
        A then A_num(obj)
        B then B_num(obj)
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(), (), None, None, TypingUnit(NuFunDef(Some(false), num, None, [], Lam(Tup(), IntLit(0))))), NuTypeDef(class, B, (), Tup(), (), None, None, TypingUnit(NuFunDef(Some(false), num, None, [], Lam(Tup(), IntLit(1))))), NuFunDef(None, A_num, None, [], Lam(Tup(_: Var(obj)), IntLit(0))), NuFunDef(None, B_num, None, [], Lam(Tup(_: Var(obj)), IntLit(1))), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(num)), If(IfThen(Var(true), New(Some((TypeName(A),[])), TypingUnit())), Some(New(Some((TypeName(B),[])), TypingUnit()))))), NuFunDef(None, main3, None, [], Lam(Tup(), Blk(NuFunDef(Some(false), obj, None, [], App(Var(foo), Tup(_: IntLit(10)))); If(IfOpApp(Var(obj), Var(is), IfBlock(IfThen(Var(A), App(Var(A_num), Tup(_: Var(obj))));IfThen(Var(B), App(Var(B_num), Tup(_: Var(obj)))))), None)))))
//│ Lifted:
//│ Lifting failed: mlscript.compiler.mono.MonomorphError: Unknown IfBody: obj is ‹(A) then A_num(obj,); (B) then B_num(obj,)›
//│ class A() {
//│   val num: () -> 0
//│ }
//│ class B() {
//│   val num: () -> 1
//│ }
//│ fun A_num: anything -> 0
//│ fun B_num: anything -> 1
//│ fun foo: anything -> (A | B)
//│ fun main3: () -> (0 | 1)
