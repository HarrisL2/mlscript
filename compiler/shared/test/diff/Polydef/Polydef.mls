:NewDefs

:nolift
:p
class X() {
    val num = 6
}
class Y() {
    val num = true
}
fun foo(pred) = if pred then X() else Y()
let obj = foo(true) in 
    if obj is
        X then obj.num
        Y then obj.num
//│ |#class| |X|(||)| |{|→|#val| |num| |#=| |6|←|↵|}|↵|#class| |Y|(||)| |{|→|#val| |num| |#=| |true|←|↵|}|↵|#fun| |foo|(|pred|)| |#=| |#if| |pred| |#then| |X|(||)| |#else| |Y|(||)|↵|#let| |obj| |#=| |foo|(|true|)| |#in| |→|#if| |obj| |is|→|X| |#then| |obj|.num|↵|Y| |#then| |obj|.num|←|←|
//│ AST: TypingUnit(List(NuTypeDef(Cls,TypeName(X),List(),Some(Tup(List())),None,None,List(),None,None,TypingUnit(List(NuFunDef(Some(false),Var(num),None,List(),Left(IntLit(6)))))), NuTypeDef(Cls,TypeName(Y),List(),Some(Tup(List())),None,None,List(),None,None,TypingUnit(List(NuFunDef(Some(false),Var(num),None,List(),Left(Var(true)))))), NuFunDef(None,Var(foo),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(pred))))),If(IfThen(Var(pred),App(Var(X),Tup(List()))),Some(App(Var(Y),Tup(List()))))))), Let(false,Var(obj),App(Var(foo),Tup(List((None,Fld(_,Var(true)))))),Blk(List(If(IfOpApp(Var(obj),Var(is),IfBlock(List(Left(IfThen(Var(X),Sel(Var(obj),Var(num)))), Left(IfThen(Var(Y),Sel(Var(obj),Var(num))))))),None))))))
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(X),List(),Some(Tup(List())),None,None,List(),None,None,TypingUnit(List(NuFunDef(Some(false),Var(num),None,List(),Left(IntLit(6)))))), NuTypeDef(Cls,TypeName(Y),List(),Some(Tup(List())),None,None,List(),None,None,TypingUnit(List(NuFunDef(Some(false),Var(num),None,List(),Left(Var(true)))))), NuFunDef(None,Var(foo),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(pred))))),If(IfThen(Var(pred),App(Var(X),Tup(List()))),Some(App(Var(Y),Tup(List()))))))), Let(false,Var(obj),App(Var(foo),Tup(List((None,Fld(_,Var(true)))))),Blk(List(If(IfOpApp(Var(obj),Var(is),IfBlock(List(Left(IfThen(Var(X),Sel(Var(obj),Var(num)))), Left(IfThen(Var(Y),Sel(Var(obj),Var(num))))))),None))))))
//│ Parsed: class X() {let num = 6}; class Y() {let num = true}; fun foo = (pred,) => if (pred) then X() else Y(); let obj = foo(true,) in {if obj is ‹(X) then (obj).num; (Y) then (obj).num›};
//│ class X() {
//│   val num: 6
//│ }
//│ class Y() {
//│   val num: true
//│ }
//│ fun foo: Object -> (X | Y)
//│ 6 | true
//│ res
//│     = 6


:pd
:nolift
:p
class X() {
    val num = 6
}
class Y() {
    val num = true
}
fun foo(pred) = if pred then X() else Y()
foo(true).num
//│ |#class| |X|(||)| |{|→|#val| |num| |#=| |6|←|↵|}|↵|#class| |Y|(||)| |{|→|#val| |num| |#=| |true|←|↵|}|↵|#fun| |foo|(|pred|)| |#=| |#if| |pred| |#then| |X|(||)| |#else| |Y|(||)|↵|foo|(|true|)|.num|
//│ AST: TypingUnit(List(NuTypeDef(Cls,TypeName(X),List(),Some(Tup(List())),None,None,List(),None,None,TypingUnit(List(NuFunDef(Some(false),Var(num),None,List(),Left(IntLit(6)))))), NuTypeDef(Cls,TypeName(Y),List(),Some(Tup(List())),None,None,List(),None,None,TypingUnit(List(NuFunDef(Some(false),Var(num),None,List(),Left(Var(true)))))), NuFunDef(None,Var(foo),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(pred))))),If(IfThen(Var(pred),App(Var(X),Tup(List()))),Some(App(Var(Y),Tup(List()))))))), Sel(App(Var(foo),Tup(List((None,Fld(_,Var(true)))))),Var(num))))
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(X),List(),Some(Tup(List())),None,None,List(),None,None,TypingUnit(List(NuFunDef(Some(false),Var(num),None,List(),Left(IntLit(6)))))), NuTypeDef(Cls,TypeName(Y),List(),Some(Tup(List())),None,None,List(),None,None,TypingUnit(List(NuFunDef(Some(false),Var(num),None,List(),Left(Var(true)))))), NuFunDef(None,Var(foo),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(pred))))),If(IfThen(Var(pred),App(Var(X),Tup(List()))),Some(App(Var(Y),Tup(List()))))))), Sel(App(Var(foo),Tup(List((None,Fld(_,Var(true)))))),Var(num))))
//│ 
//│ Polydef:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(X),List(),Some(Tup(List())),None,None,List(),None,None,TypingUnit(List(NuFunDef(Some(false),Var(num),None,List(),Left(IntLit(6)))))), NuTypeDef(Cls,TypeName(Y),List(),Some(Tup(List())),None,None,List(),None,None,TypingUnit(List(NuFunDef(Some(false),Var(num),None,List(),Left(Var(true)))))), NuFunDef(None,Var(foo),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(pred))))),If(IfThen(Var(pred),App(Var(X),Tup(List()))),Some(App(Var(Y),Tup(List()))))))), Let(false,Var(selRes26),App(Var(foo),Tup(List((None,Fld(_,Var(true)))))),Blk(List(If(IfOpApp(Var(selRes26),Var(is),IfBlock(List(Left(IfThen(Var(Y),Sel(Var(selRes26),Var(num)))), Left(IfThen(Var(X),Sel(Var(selRes26),Var(num))))))),None))))))
//│ {class X() {let num = 6}
//│  class Y() {let num = true}
//│  fun foo = (pred,) => if (pred) then X() else Y()
//│  let selRes26 = foo(true,) in {if selRes26 is ‹(Y) then (selRes26).num
//│  (X) then (selRes26).num›}}
//│ 
//│ 
//│ 
//│ Parsed: class X() {let num = 6}; class Y() {let num = true}; fun foo = (pred,) => if (pred) then X() else Y(); let selRes26 = foo(true,) in {if selRes26 is ‹(Y) then (selRes26).num; (X) then (selRes26).num›};
//│ class X() {
//│   val num: 6
//│ }
//│ class Y() {
//│   val num: true
//│ }
//│ fun foo: Object -> (X | Y)
//│ 6 | true
//│ res
//│     = 6
