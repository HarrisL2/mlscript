:NewDefs

:mono
:rc
1
2
3
//│ Parsed:
//│ TypingUnit(IntLit(1), IntLit(2), IntLit(3))
//│ Lifted:
//│ TypingUnit(IntLit(1), IntLit(2), IntLit(3))
//│ TypingUnit {Code(List(1)); Code(List(2)); Code(List(3))}
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun main$$0() =
//│   #1
//│ fun main$$2() =
//│   #3
//│ fun main$$1() =
//│   #2
//│ main$$0()
//│ main$$1()
//│ main$$2()
//│ fun main$$0: () -> 1
//│ fun main$$2: () -> 3
//│ fun main$$1: () -> 2
//│ 3
//│ res
//│     = 1
//│ res
//│     = 2
//│ res
//│     = 3

:mono
:rc
let x = 1
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), x, None, [], IntLit(1)))
//│ Lifted:
//│ TypingUnit(NuFunDef(Some(false), x$1, None, [], IntLit(1)))
//│ TypingUnit {let x$1 = 1}
//│ Mono:
//│ 
//│ Defunc result: 
//│ let x$1 =
//│   #1
//│ let x$1: 1
//│ x$1
//│     = 1

:mono
:rc
fun const3() = 3
const3()
const3
//│ Parsed:
//│ TypingUnit(NuFunDef(None, const3, None, [], Lam(Tup(), IntLit(3))), App(Var(const3), Tup()), Var(const3))
//│ Lifted:
//│ TypingUnit(NuFunDef(None, const3$1, None, [], Lam(Tup(), IntLit(3))), App(Var(const3$1), Tup()), Var(const3$1))
//│ TypingUnit {
//│   fun const3$1 = () => 3
//│   Code(List(const3$1()))
//│   Code(List(const3$1))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun const3$1() =
//│   #3
//│ fun main$$2() =
//│   const3$1
//│ fun main$$1() =
//│   const3$1()
//│ main$$1()
//│ main$$2()
//│ fun const3$1: () -> 3
//│ fun main$$2: () -> () -> 3
//│ fun main$$1: () -> 3
//│ () -> 3
//│ res
//│     = 3
//│ res
//│     = [Function: const3$1]

:mono
:rc
fun addOne(x) = x+1
addOne(5)
//│ Parsed:
//│ TypingUnit(NuFunDef(None, addOne, None, [], Lam(Tup(_: Var(x)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), App(Var(addOne), Tup(_: IntLit(5))))
//│ Lifted:
//│ TypingUnit(NuFunDef(None, addOne$1, None, [], Lam(Tup(_: Var(x)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), App(Var(addOne$1), Tup(_: IntLit(5))))
//│ TypingUnit {
//│   fun addOne$1 = (x,) => +(x, 1,)
//│   Code(List(addOne$1(5,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun addOne$1(x) =
//│   +(x, #1)
//│ fun main$$1() =
//│   addOne$1(#5)
//│ main$$1()
//│ fun addOne$1: Int -> Int
//│ fun main$$1: () -> Int
//│ Int
//│ res
//│     = 6

:mono
:rc
fun addOneTypedParam(x: Int) = x+1
addOneTypedParam(5)
//│ Parsed:
//│ TypingUnit(NuFunDef(None, addOneTypedParam, None, [], Lam(Tup(x: Var(Int)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), App(Var(addOneTypedParam), Tup(_: IntLit(5))))
//│ Lifted:
//│ TypingUnit(NuFunDef(None, addOneTypedParam$1, None, [], Lam(Tup(x: Var(Int)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), App(Var(addOneTypedParam$1), Tup(_: IntLit(5))))
//│ TypingUnit {
//│   fun addOneTypedParam$1 = (x: Int,) => +(x, 1,)
//│   Code(List(addOneTypedParam$1(5,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun addOneTypedParam$1(x) =
//│   +(x, #1)
//│ fun main$$1() =
//│   addOneTypedParam$1(#5)
//│ main$$1()
//│ fun addOneTypedParam$1: (x: Int) -> Int
//│ fun main$$1: () -> Int
//│ Int
//│ res
//│     = 6

:mono
:rc
fun min(x: Int, y: Int) = if x > y then y else x
min(3,4)
min(4,3)
//│ Parsed:
//│ TypingUnit(NuFunDef(None, min, None, [], Lam(Tup(x: Var(Int), y: Var(Int)), If(IfThen(App(Var(>), Tup(_: Var(x), _: Var(y))), Var(y)), Some(Var(x))))), App(Var(min), Tup(_: IntLit(3), _: IntLit(4))), App(Var(min), Tup(_: IntLit(4), _: IntLit(3))))
//│ Lifted:
//│ TypingUnit(NuFunDef(None, min$1, None, [], Lam(Tup(x: Var(Int), y: Var(Int)), If(IfThen(App(Var(>), Tup(_: Var(x), _: Var(y))), Var(y)), Some(Var(x))))), App(Var(min$1), Tup(_: IntLit(3), _: IntLit(4))), App(Var(min$1), Tup(_: IntLit(4), _: IntLit(3))))
//│ TypingUnit {
//│   fun min$1 = (x: Int, y: Int,) => if (>(x, y,)) then y else x
//│   Code(List(min$1(3, 4,)))
//│   Code(List(min$1(4, 3,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun min$1(x, y) =
//│   if >(x, y) then y else x
//│ fun main$$2() =
//│   min$1(#4, #3)
//│ fun main$$1() =
//│   min$1(#3, #4)
//│ main$$1()
//│ main$$2()
//│ fun min$1: (x: Int, y: Int) -> Int
//│ fun main$$2: () -> Int
//│ fun main$$1: () -> Int
//│ Int
//│ res
//│     = 3
//│ res
//│     = 3


// FIXME: Isolation in class/NuTypeDef body removed?
//:mono
//:rc
:p
class IntPlusY(x: Int) {
  val get =  x
}
val three = IntPlusY(5)
three.get
//│ |#class| |IntPlusY|(|x|#:| |Int|)| |{|→|#val| |get| |#=| |x|←|↵|}|↵|#val| |three| |#=| |IntPlusY|(|5|)|↵|three|.get|
//│ AST: TypingUnit(NuTypeDef(class, IntPlusY, (), Tup(x: Var(Int)), (), None, None, TypingUnit(NuFunDef(Some(false), get, None, [], Var(x)))), NuFunDef(Some(false), three, None, [], App(Var(IntPlusY), Tup(_: IntLit(5)))), Sel(Var(three), get))
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, IntPlusY, (), Tup(x: Var(Int)), (), None, None, TypingUnit(NuFunDef(Some(false), get, None, [], Var(x)))), NuFunDef(Some(false), three, None, [], App(Var(IntPlusY), Tup(_: IntLit(5)))), Sel(Var(three), get))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, IntPlusY$1, (), Tup(x: Var(Int)), (), None, None, TypingUnit(NuFunDef(Some(false), get, None, [], Sel(Var(this), x)))), NuFunDef(Some(false), three$1, None, [], App(Var(IntPlusY$1), Tup(_: IntLit(5)))), Sel(Var(three$1), get))
//│ TypingUnit {
//│   class IntPlusY$1([x: Int,]) {let get = (this).x}
//│   let three$1 = IntPlusY$1(5,)
//│   Code(List((three$1).get))
//│ }
//│ Parsed: TypingUnit(NuTypeDef(class, IntPlusY, (), Tup(x: Var(Int)), (), None, None, TypingUnit(NuFunDef(Some(false), get, None, [], Var(x)))), NuFunDef(Some(false), three, None, [], App(Var(IntPlusY), Tup(_: IntLit(5)))), Sel(Var(three), get))
//│ class IntPlusY(x: Int) {
//│   val get: Int
//│ }
//│ val three: IntPlusY
//│ Int
//│ three
//│       = IntPlusY {}
//│ res
//│     = 5
//| NuTypeDef(class, IntPlusY, (), Tup(x: Var(B)), (), None, None, TypingUnit(NuFunDef(None, get, None, [], Lam(Tup(_: Var(y)), Var(x))))), NuFunDef(Some(false), three, None, [], App(Var(IntPlusY), Tup(_: App(Var(B), Tup())))), App(Sel(Var(three), get), Tup(_: IntLit(1))))

:mono
:rc
let x = let x = 3 in [x, 4]
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), x, None, [], Let(false, x, IntLit(3), Tup(_: Var(x), _: IntLit(4)))))
//│ Lifted:
//│ TypingUnit(NuFunDef(Some(false), x$1, None, [], Let(false, x, IntLit(3), Tup(_: Var(x), _: IntLit(4)))))
//│ TypingUnit {let x$1 = let x = 3 in [x, 4,]}
//│ Mono:
//│ 
//│ Defunc result: 
//│ let x$1 =
//│   let x = #3 in (x, #4)
//│ let x$1: [3, 4]
//│ x$1
//│     = [ 3, 4 ]

:rc
:mono
val x = 2
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), x, None, [], IntLit(2)))
//│ Lifted:
//│ TypingUnit(NuFunDef(Some(false), x$1, None, [], IntLit(2)))
//│ TypingUnit {let x$1 = 2}
//│ Mono:
//│ 
//│ Defunc result: 
//│ let x$1 =
//│   #2
//│ let x$1: 2
//│ x$1
//│     = 2

:mono
:rc
let x() = 2
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), x, None, [], Lam(Tup(), IntLit(2))))
//│ Lifted:
//│ TypingUnit(NuFunDef(Some(false), x$1, None, [], Lam(Tup(), IntLit(2))))
//│ TypingUnit {let x$1 = () => 2}
//│ Mono:
//│ 
//│ Defunc result: 
//│ let x$1() =
//│   #2
//│ let x$1: () -> 2
//│ x$1
//│     = [Function: x$17]

:mono
:rc
let x = 
  log("should show once")
  3
x
x
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), x, None, [], Blk(App(Var(log), Tup(_: StrLit(should show once))); IntLit(3))), Var(x), Var(x))
//│ Lifted:
//│ TypingUnit(NuFunDef(Some(false), x$1, None, [], Blk(App(Var(log), Tup(_: StrLit(should show once))); IntLit(3))), Var(x$1), Var(x$1))
//│ TypingUnit {
//│   let x$1 = {log("should show once",); 3}
//│   Code(List(x$1))
//│   Code(List(x$1))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ let x$1 =
//│   log(#should show once);#3
//│ fun main$$2() =
//│   x$1
//│ fun main$$1() =
//│   x$1
//│ main$$1()
//│ main$$2()
//│ let x$1: 3
//│ fun main$$2: () -> 3
//│ fun main$$1: () -> 3
//│ 3
//│ x$1
//│     = 3
//│ // Output
//│ should show once
//│ res
//│     = 3
//│ res
//│     = 3

:mono
:rc
fun x =
  log("should show twice")
  3
x
x
//│ Parsed:
//│ TypingUnit(NuFunDef(None, x, None, [], Blk(App(Var(log), Tup(_: StrLit(should show twice))); IntLit(3))), Var(x), Var(x))
//│ Lifted:
//│ TypingUnit(NuFunDef(None, x$1, None, [], Blk(App(Var(log), Tup(_: StrLit(should show twice))); IntLit(3))), Var(x$1), Var(x$1))
//│ TypingUnit {
//│   fun x$1 = {log("should show twice",); 3}
//│   Code(List(x$1))
//│   Code(List(x$1))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun x$1 =
//│   log(#should show twice);#3
//│ fun main$$2() =
//│   x$1
//│ fun main$$1() =
//│   x$1
//│ main$$1()
//│ main$$2()
//│ fun x$1: 3
//│ fun main$$2: () -> 3
//│ fun main$$1: () -> 3
//│ 3
//│ res
//│     = 3
//│ // Output
//│ should show twice
//│ res
//│     = 3
//│ // Output
//│ should show twice
