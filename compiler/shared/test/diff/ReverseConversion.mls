:NewDefs

:mono
:rc
1
2
3
//│ Lifted:
//│ TypingUnit {Code(List(1)); Code(List(2)); Code(List(3))}
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun main$$0() =
//│   #1
//│ fun main$$2() =
//│   #3
//│ fun main$$1() =
//│   #2
//│ main$$0()
//│ main$$1()
//│ main$$2()
//│ fun main$$0: () -> 1
//│ fun main$$2: () -> 3
//│ fun main$$1: () -> 2
//│ 3
//│ res
//│     = 1
//│ res
//│     = 2
//│ res
//│     = 3

:mono
:rc
let x = 1
//│ Lifted:
//│ TypingUnit {let x$1 = 1}
//│ Mono:
//│ 
//│ Defunc result: 
//│ let x$1 =
//│   #1
//│ let x$1: 1
//│ x$1
//│     = 1

:mono
:rc
fun const3() = 3
const3()
const3
//│ Lifted:
//│ TypingUnit {
//│   fun const3$1 = () => 3
//│   Code(List(const3$1()))
//│   Code(List(const3$1))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun const3$1() =
//│   #3
//│ fun main$$2() =
//│   const3$1
//│ fun main$$1() =
//│   const3$1()
//│ main$$1()
//│ main$$2()
//│ fun const3$1: () -> 3
//│ fun main$$2: () -> () -> 3
//│ fun main$$1: () -> 3
//│ () -> 3
//│ res
//│     = 3
//│ res
//│     = [Function: const3$1]

:mono
:rc
fun addOne(x) = x+1
addOne(5)
//│ Lifted:
//│ TypingUnit {
//│   fun addOne$1 = (x,) => +(x, 1,)
//│   Code(List(addOne$1(5,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun addOne$1(x) =
//│   +(x, #1)
//│ fun main$$1() =
//│   addOne$1(#5)
//│ main$$1()
//│ fun addOne$1: Int -> Int
//│ fun main$$1: () -> Int
//│ Int
//│ res
//│     = 6

:mono
:rc
fun addOneTypedParam(x: Int) = x+1
addOneTypedParam(5)
//│ Lifted:
//│ TypingUnit {
//│   fun addOneTypedParam$1 = (x: Int,) => +(x, 1,)
//│   Code(List(addOneTypedParam$1(5,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun addOneTypedParam$1(x) =
//│   +(x, #1)
//│ fun main$$1() =
//│   addOneTypedParam$1(#5)
//│ main$$1()
//│ fun addOneTypedParam$1: (x: Int) -> Int
//│ fun main$$1: () -> Int
//│ Int
//│ res
//│     = 6

:mono
:rc
fun min(x: Int, y: Int) = if x > y then y else x
min(3,4)
min(4,3)
//│ Lifted:
//│ TypingUnit {
//│   fun min$1 = (x: Int, y: Int,) => if (>(x, y,)) then y else x
//│   Code(List(min$1(3, 4,)))
//│   Code(List(min$1(4, 3,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun min$1(x, y) =
//│   if >(x, y) then y else x
//│ fun main$$2() =
//│   min$1(#4, #3)
//│ fun main$$1() =
//│   min$1(#3, #4)
//│ main$$1()
//│ main$$2()
//│ fun min$1: (x: Int, y: Int) -> Int
//│ fun main$$2: () -> Int
//│ fun main$$1: () -> Int
//│ Int
//│ res
//│     = 3
//│ res
//│     = 3


// FIXME: Isolation in class/NuTypeDef body removed?
//:mono
//:rc
:p
class IntPlusY(x: Int) {
  val get =  x
}
val three = IntPlusY(5)
three.get
//│ |#class| |IntPlusY|(|x|#:| |Int|)| |{|→|#val| |get| |#=| |x|←|↵|}|↵|#val| |three| |#=| |IntPlusY|(|5|)|↵|three|.get|
//│ AST: TypingUnit(List(NuTypeDef(Cls,TypeName(IntPlusY),List(),Some(Tup(List((Some(Var(x)),Fld(_,Var(Int)))))),None,None,List(),None,None,TypingUnit(List(NuFunDef(Some(false),Var(get),None,List(),Left(Var(x)))))), NuFunDef(Some(false),Var(three),None,List(),Left(App(Var(IntPlusY),Tup(List((None,Fld(_,IntLit(5)))))))), Sel(Var(three),Var(get))))
//│ Lifted:
//│ TypingUnit {
//│   class IntPlusY$1([x: Int,]) {let get = (this).x}
//│   let three$1 = IntPlusY$1(5,)
//│   Code(List((three$1).get))
//│ }
//│ Parsed: class IntPlusY(x: Int,) {let get = x}; let three = IntPlusY(5,); (three).get;
//│ class IntPlusY(x: Int) {
//│   val get: Int
//│ }
//│ val three: IntPlusY
//│ Int
//│ three
//│       = IntPlusY {}
//│ res
//│     = 5
//| NuTypeDef(class, IntPlusY, (), Tup(x: Var(B)), (), None, None, TypingUnit(NuFunDef(None, get, None, [], Lam(Tup(_: Var(y)), Var(x))))), NuFunDef(Some(false), three, None, [], App(Var(IntPlusY), Tup(_: App(Var(B), Tup())))), App(Sel(Var(three), get), Tup(_: IntLit(1))))

:mono
:rc
let x = let x = 3 in [x, 4]
//│ Lifted:
//│ TypingUnit {let x$1 = let x = 3 in [x, 4,]}
//│ Mono:
//│ 
//│ Defunc result: 
//│ let x$1 =
//│   let x = #3 in (x, #4)
//│ let x$1: [3, 4]
//│ x$1
//│     = [ 3, 4 ]

:rc
:mono
val x = 2
//│ Lifted:
//│ TypingUnit {let x$1 = 2}
//│ Mono:
//│ 
//│ Defunc result: 
//│ let x$1 =
//│   #2
//│ let x$1: 2
//│ x$1
//│     = 2

:mono
:rc
let x() = 2
//│ Lifted:
//│ TypingUnit {let x$1 = () => 2}
//│ Mono:
//│ 
//│ Defunc result: 
//│ let x$1() =
//│   #2
//│ let x$1: () -> 2
//│ x$1
//│     = [Function: x$13]

:mono
:rc
let x = 
  log("should show once")
  3
x
x
//│ Lifted:
//│ TypingUnit {
//│   let x$1 = {log("should show once",); 3}
//│   Code(List(x$1))
//│   Code(List(x$1))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ let x$1 =
//│   log(#should show once);#3
//│ fun main$$2() =
//│   x$1
//│ fun main$$1() =
//│   x$1
//│ main$$1()
//│ main$$2()
//│ let x$1: 3
//│ fun main$$2: () -> 3
//│ fun main$$1: () -> 3
//│ 3
//│ x$1
//│     = 3
//│ // Output
//│ should show once
//│ res
//│     = 3
//│ res
//│     = 3

:mono
:rc
fun x =
  log("should show twice")
  3
x
x
//│ Lifted:
//│ TypingUnit {
//│   fun x$1 = {log("should show twice",); 3}
//│   Code(List(x$1))
//│   Code(List(x$1))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun x$1 =
//│   log(#should show twice);#3
//│ fun main$$2() =
//│   x$1
//│ fun main$$1() =
//│   x$1
//│ main$$1()
//│ main$$2()
//│ fun x$1: 3
//│ fun main$$2: () -> 3
//│ fun main$$1: () -> 3
//│ 3
//│ res
//│     = 3
//│ // Output
//│ should show twice
//│ res
//│     = 3
//│ // Output
//│ should show twice
