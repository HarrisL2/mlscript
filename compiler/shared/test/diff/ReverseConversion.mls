:NewDefs

:p
let x = 1
//│ |#let| |x| |#=| |1|
//│ AST: TypingUnit(NuFunDef(Some(false), x, None, [], IntLit(1)))
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), x, None, [], IntLit(1)))
//│ Lifted:
//│ TypingUnit(NuFunDef(Some(false), x$1, None, [], IntLit(1)))
//│ Parsed: TypingUnit(NuFunDef(Some(false), x, None, [], IntLit(1)))
//│ let x: 1
//│ x
//│   = 1

:mono
:p
:rc
1
2
3
//│ |1|↵|2|↵|3|
//│ AST: TypingUnit(IntLit(1), IntLit(2), IntLit(3))
//│ Parsed:
//│ TypingUnit(IntLit(1), IntLit(2), IntLit(3))
//│ Lifted:
//│ TypingUnit(IntLit(1), IntLit(2), IntLit(3))
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun main$$0() =
//│   #1
//│ fun main$$2() =
//│   #3
//│ fun main$$1() =
//│   #2
//│ main$$0()
//│ main$$1()
//│ main$$2()
//│ Parsed: TypingUnit(NuFunDef(None, main$$0, None, [], Lam(Tup(), IntLit(1))), NuFunDef(None, main$$2, None, [], Lam(Tup(), IntLit(3))), NuFunDef(None, main$$1, None, [], Lam(Tup(), IntLit(2))), App(Var(main$$0), Tup()), App(Var(main$$1), Tup()), App(Var(main$$2), Tup()))
//│ fun main$$0: () -> 1
//│ fun main$$2: () -> 3
//│ fun main$$1: () -> 2
//│ 3
//│ res
//│     = 1
//│ res
//│     = 2
//│ res
//│     = 3

:mono
:rc
:p
fun const3() = 3
const3()
//│ |#fun| |const3|(||)| |#=| |3|↵|const3|(||)|
//│ AST: TypingUnit(NuFunDef(None, const3, None, [], Lam(Tup(), IntLit(3))), App(Var(const3), Tup()))
//│ Parsed:
//│ TypingUnit(NuFunDef(None, const3, None, [], Lam(Tup(), IntLit(3))), App(Var(const3), Tup()))
//│ Lifted:
//│ TypingUnit(NuFunDef(None, const3$1, None, [], Lam(Tup(), IntLit(3))), App(Var(const3$1), Tup()))
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun const3$1() =
//│   #3
//│ fun main$$1() =
//│   const3$1()
//│ main$$1()
//│ Parsed: TypingUnit(NuFunDef(None, const3$1, None, [], Lam(Tup(), IntLit(3))), NuFunDef(None, main$$1, None, [], Lam(Tup(), App(Var(const3$1), Tup()))), App(Var(main$$1), Tup()))
//│ fun const3$1: () -> 3
//│ fun main$$1: () -> 3
//│ 3
//│ res
//│     = 3

:mono
:rc
:p
fun addOne(x) = x+1
addOne(5)
//│ |#fun| |addOne|(|x|)| |#=| |x|+|1|↵|addOne|(|5|)|
//│ AST: TypingUnit(NuFunDef(None, addOne, None, [], Lam(Tup(_: Var(x)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), App(Var(addOne), Tup(_: IntLit(5))))
//│ Parsed:
//│ TypingUnit(NuFunDef(None, addOne, None, [], Lam(Tup(_: Var(x)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), App(Var(addOne), Tup(_: IntLit(5))))
//│ Lifted:
//│ TypingUnit(NuFunDef(None, addOne$1, None, [], Lam(Tup(_: Var(x)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), App(Var(addOne$1), Tup(_: IntLit(5))))
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun addOne$1(x) =
//│   +(x, #1)
//│ fun main$$1() =
//│   addOne$1(#5)
//│ main$$1()
//│ Parsed: TypingUnit(NuFunDef(None, addOne$1, None, [], Lam(Tup(_: Var(x)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), NuFunDef(None, main$$1, None, [], Lam(Tup(), App(Var(addOne$1), Tup(_: IntLit(5))))), App(Var(main$$1), Tup()))
//│ fun addOne$1: Int -> Int
//│ fun main$$1: () -> Int
//│ Int
//│ res
//│     = 6

:mono
:rc
:p
fun addOneTypedParam(x: Int) = x+1
addOneTypedParam(5)
//│ |#fun| |addOneTypedParam|(|x|#:| |Int|)| |#=| |x|+|1|↵|addOneTypedParam|(|5|)|
//│ AST: TypingUnit(NuFunDef(None, addOneTypedParam, None, [], Lam(Tup(x: Var(Int)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), App(Var(addOneTypedParam), Tup(_: IntLit(5))))
//│ Parsed:
//│ TypingUnit(NuFunDef(None, addOneTypedParam, None, [], Lam(Tup(x: Var(Int)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), App(Var(addOneTypedParam), Tup(_: IntLit(5))))
//│ Lifted:
//│ TypingUnit(NuFunDef(None, addOneTypedParam$1, None, [], Lam(Tup(x: Var(Int)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), App(Var(addOneTypedParam$1), Tup(_: IntLit(5))))
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun addOneTypedParam$1(x) =
//│   +(x, #1)
//│ fun main$$1() =
//│   addOneTypedParam$1(#5)
//│ main$$1()
//│ Parsed: TypingUnit(NuFunDef(None, addOneTypedParam$1, None, [], Lam(Tup(x: Var(Int)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), NuFunDef(None, main$$1, None, [], Lam(Tup(), App(Var(addOneTypedParam$1), Tup(_: IntLit(5))))), App(Var(main$$1), Tup()))
//│ fun addOneTypedParam$1: (x: Int) -> Int
//│ fun main$$1: () -> Int
//│ Int
//│ res
//│     = 6

:mono
:rc
:p
fun min(x: Int, y: Int) = if x > y then y else x
min(3,4)
min(4,3)
//│ |#fun| |min|(|x|#:| |Int|,| |y|#:| |Int|)| |#=| |#if| |x| |>| |y| |#then| |y| |#else| |x|↵|min|(|3|,|4|)|↵|min|(|4|,|3|)|
//│ AST: TypingUnit(NuFunDef(None, min, None, [], Lam(Tup(x: Var(Int), y: Var(Int)), If(IfThen(App(Var(>), Tup(_: Var(x), _: Var(y))), Var(y), Some(Var(x))))), App(Var(min), Tup(_: IntLit(3), _: IntLit(4))), App(Var(min), Tup(_: IntLit(4), _: IntLit(3))))
//│ Parsed:
//│ TypingUnit(NuFunDef(None, min, None, [], Lam(Tup(x: Var(Int), y: Var(Int)), If(IfThen(App(Var(>), Tup(_: Var(x), _: Var(y))), Var(y), Some(Var(x))))), App(Var(min), Tup(_: IntLit(3), _: IntLit(4))), App(Var(min), Tup(_: IntLit(4), _: IntLit(3))))
//│ Lifted:
//│ TypingUnit(NuFunDef(None, min$1, None, [], Lam(Tup(x: Var(Int), y: Var(Int)), If(IfThen(App(Var(>), Tup(_: Var(x), _: Var(y))), Var(y), Some(Var(x))))), App(Var(min$1), Tup(_: IntLit(3), _: IntLit(4))), App(Var(min$1), Tup(_: IntLit(4), _: IntLit(3))))
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun min$1(x, y) =
//│   if >(x, y) then y else x
//│ fun main$$2() =
//│   min$1(#4, #3)
//│ fun main$$1() =
//│   min$1(#3, #4)
//│ main$$1()
//│ main$$2()
//│ Parsed: TypingUnit(NuFunDef(None, min$1, None, [], Lam(Tup(x: Var(Int), y: Var(Int)), If(IfThen(App(Var(>), Tup(_: Var(x), _: Var(y))), Var(y), Some(Var(x))))), NuFunDef(None, main$$2, None, [], Lam(Tup(), App(Var(min$1), Tup(_: IntLit(4), _: IntLit(3))))), NuFunDef(None, main$$1, None, [], Lam(Tup(), App(Var(min$1), Tup(_: IntLit(3), _: IntLit(4))))), App(Var(main$$1), Tup()), App(Var(main$$2), Tup()))
//│ fun min$1: (x: Int, y: Int) -> Int
//│ fun main$$2: () -> Int
//│ fun main$$1: () -> Int
//│ Int
//│ res
//│     = 3
//│ res
//│     = 3

:mono
:p
:rc
class IntPlusY(x: Int) {
  val get =  x
}
val three = IntPlusY(5)
three.get
//│ |#class| |IntPlusY|(|x|#:| |Int|)| |{|→|#val| |get| |#=| |x|←|↵|}|↵|#val| |three| |#=| |IntPlusY|(|5|)|↵|three|.get|
//│ AST: TypingUnit(NuTypeDef(class, IntPlusY, (), Tup(x: Var(Int)), (), None, None, TypingUnit(NuFunDef(Some(false), get, None, [], Var(x)))), NuFunDef(Some(false), three, None, [], App(Var(IntPlusY), Tup(_: IntLit(5)))), Sel(Var(three), get))
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, IntPlusY, (), Tup(x: Var(Int)), (), None, None, TypingUnit(NuFunDef(Some(false), get, None, [], Var(x)))), NuFunDef(Some(false), three, None, [], App(Var(IntPlusY), Tup(_: IntLit(5)))), Sel(Var(three), get))
//│ Lifted:
//│ TypingUnit(NuTypeDef(class, IntPlusY$1, (), Tup(x: Var(Int)), (), None, None, TypingUnit(NuFunDef(Some(false), get, None, [], Lam(Tup(), Sel(Var(this), x))))), NuFunDef(Some(false), three$1, None, [], App(Var(IntPlusY$1), Tup(_: IntLit(5)))), Sel(Var(three), get))
//│ Mono:
//│ 
//│ Defunc result: 
//│ class IntPlusY$1(x) {
//│ }
//│ fun three$1() =
//│   IntPlusY$1(#5)
//│ fun main$$2() =
//│   three.get
//│ main$$2()
//│ Parsed: TypingUnit(NuTypeDef(class, IntPlusY$1, (), Tup(x: Var(Int)), (), None, None, TypingUnit()), NuFunDef(Some(false), three$1, None, [], App(Var(IntPlusY$1), Tup(_: IntLit(5)))), NuFunDef(None, main$$2, None, [], Lam(Tup(), Sel(Var(three), get))), App(Var(main$$2), Tup()))
//│ ╔══[ERROR] identifier not found: three
//│ ╙──
//│ class IntPlusY$1(x: Int)
//│ let three$1: IntPlusY$1
//│ fun main$$2: () -> error
//│ error
//│ Code generation encountered an error:
//│   unresolved symbol three
//| NuTypeDef(class, IntPlusY, (), Tup(x: Var(B)), (), None, None, TypingUnit(NuFunDef(None, get, None, [], Lam(Tup(_: Var(y)), Var(x))))), NuFunDef(Some(false), three, None, [], App(Var(IntPlusY), Tup(_: App(Var(B), Tup())))), App(Sel(Var(three), get), Tup(_: IntLit(1))))

:mono
:p
:rc
let x = let x = 3 in [x, 4]
//│ |#let| |x| |#=| |#let| |x| |#=| |3| |#in| |[|x|,| |4|]|
//│ AST: TypingUnit(NuFunDef(Some(false), x, None, [], Let(false, x, IntLit(3), Tup(_: Var(x), _: IntLit(4)))))
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), x, None, [], Let(false, x, IntLit(3), Tup(_: Var(x), _: IntLit(4)))))
//│ Lifted:
//│ TypingUnit(NuFunDef(Some(false), x$1, None, [], Let(false, x, IntLit(3), Tup(_: Var(x), _: IntLit(4)))))
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun x$1() =
//│   let x = #3 in (x, #4)
//│ Parsed: TypingUnit(NuFunDef(Some(false), x$1, None, [], Let(false, x, IntLit(3), Tup(_: Var(x), _: IntLit(4)))))
//│ let x$1: [3, 4]
//│ x$1
//│     = [ 3, 4 ]

:p
:rc
:mono
val x = 2
//│ |#val| |x| |#=| |2|
//│ AST: TypingUnit(NuFunDef(Some(false), x, None, [], IntLit(2)))
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), x, None, [], IntLit(2)))
//│ Lifted:
//│ TypingUnit(NuFunDef(Some(false), x$1, None, [], IntLit(2)))
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun x$1() =
//│   #2
//│ Parsed: TypingUnit(NuFunDef(Some(false), x$1, None, [], IntLit(2)))
//│ let x$1: 2
//│ x$1
//│     = 2

:p
:mono
:rc
let x() = 2
//│ |#let| |x|(||)| |#=| |2|
//│ AST: TypingUnit(NuFunDef(Some(false), x, None, [], Lam(Tup(), IntLit(2))))
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), x, None, [], Lam(Tup(), IntLit(2))))
//│ Lifted:
//│ TypingUnit(NuFunDef(Some(false), x$1, None, [], Lam(Tup(), IntLit(2))))
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun x$1() =
//│   #2
//│ Parsed: TypingUnit(NuFunDef(Some(false), x$1, None, [], Lam(Tup(), IntLit(2))))
//│ let x$1: () -> 2
//│ x$1
//│     = [Function: x$12]
