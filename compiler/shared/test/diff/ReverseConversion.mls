:NewDefs

:mono
:p
:rc
1
2
3
//│ |1|↵|2|↵|3|
//│ AST: TypingUnit(IntLit(1), IntLit(2), IntLit(3))
//│ Parsed:
//│ TypingUnit(IntLit(1), IntLit(2), IntLit(3))
//│ Lifted:
//│ TypingUnit {Code(List(1)); Code(List(2)); Code(List(3))}
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun main$$0() =
//│   #1
//│ fun main$$2() =
//│   #3
//│ fun main$$1() =
//│   #2
//│ main$$0()
//│ main$$1()
//│ main$$2()
//│ Parsed: TypingUnit(NuFunDef(None, main$$0, None, [], Lam(Tup(), IntLit(1))), NuFunDef(None, main$$2, None, [], Lam(Tup(), IntLit(3))), NuFunDef(None, main$$1, None, [], Lam(Tup(), IntLit(2))), App(Var(main$$0), Tup()), App(Var(main$$1), Tup()), App(Var(main$$2), Tup()))
//│ fun main$$0: () -> 1
//│ fun main$$2: () -> 3
//│ fun main$$1: () -> 2
//│ 3
//│ res
//│     = 1
//│ res
//│     = 2
//│ res
//│     = 3

:mono
:rc
:p
fun const3() = 3
const3()
//│ |#fun| |const3|(||)| |#=| |3|↵|const3|(||)|
//│ AST: TypingUnit(NuFunDef(None, const3, None, [], Lam(Tup(), IntLit(3))), App(Var(const3), Tup()))
//│ Parsed:
//│ TypingUnit(NuFunDef(None, const3, None, [], Lam(Tup(), IntLit(3))), App(Var(const3), Tup()))
//│ Lifted:
//│ TypingUnit {fun const3$1 = () => 3; Code(List(const3$1()))}
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun const3$1() =
//│   #3
//│ fun main$$1() =
//│   const3$1()
//│ main$$1()
//│ Parsed: TypingUnit(NuFunDef(None, const3$1, None, [], Lam(Tup(), IntLit(3))), NuFunDef(None, main$$1, None, [], Lam(Tup(), App(Var(const3$1), Tup()))), App(Var(main$$1), Tup()))
//│ fun const3$1: () -> 3
//│ fun main$$1: () -> 3
//│ 3
//│ res
//│     = 3

:mono
:rc
:p
fun addOne(x) = x+1
addOne(5)
//│ |#fun| |addOne|(|x|)| |#=| |x|+|1|↵|addOne|(|5|)|
//│ AST: TypingUnit(NuFunDef(None, addOne, None, [], Lam(Tup(_: Var(x)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), App(Var(addOne), Tup(_: IntLit(5))))
//│ Parsed:
//│ TypingUnit(NuFunDef(None, addOne, None, [], Lam(Tup(_: Var(x)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), App(Var(addOne), Tup(_: IntLit(5))))
//│ Lifted:
//│ TypingUnit {
//│   fun addOne$1 = (x,) => +(x, 1,)
//│   Code(List(addOne$1(5,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun addOne$1(x) =
//│   +(x, #1)
//│ fun main$$1() =
//│   addOne$1(#5)
//│ main$$1()
//│ Parsed: TypingUnit(NuFunDef(None, addOne$1, None, [], Lam(Tup(_: Var(x)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), NuFunDef(None, main$$1, None, [], Lam(Tup(), App(Var(addOne$1), Tup(_: IntLit(5))))), App(Var(main$$1), Tup()))
//│ fun addOne$1: Int -> Int
//│ fun main$$1: () -> Int
//│ Int
//│ res
//│     = 6

:mono
:rc
:p
fun addOneTypedParam(x: Int) = x+1
addOneTypedParam(5)
//│ |#fun| |addOneTypedParam|(|x|#:| |Int|)| |#=| |x|+|1|↵|addOneTypedParam|(|5|)|
//│ AST: TypingUnit(NuFunDef(None, addOneTypedParam, None, [], Lam(Tup(x: Var(Int)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), App(Var(addOneTypedParam), Tup(_: IntLit(5))))
//│ Parsed:
//│ TypingUnit(NuFunDef(None, addOneTypedParam, None, [], Lam(Tup(x: Var(Int)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), App(Var(addOneTypedParam), Tup(_: IntLit(5))))
//│ Lifted:
//│ TypingUnit {
//│   fun addOneTypedParam$1 = (x: Int,) => +(x, 1,)
//│   Code(List(addOneTypedParam$1(5,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun addOneTypedParam$1(x) =
//│   +(x, #1)
//│ fun main$$1() =
//│   addOneTypedParam$1(#5)
//│ main$$1()
//│ Parsed: TypingUnit(NuFunDef(None, addOneTypedParam$1, None, [], Lam(Tup(x: Var(Int)), App(Var(+), Tup(_: Var(x), _: IntLit(1))))), NuFunDef(None, main$$1, None, [], Lam(Tup(), App(Var(addOneTypedParam$1), Tup(_: IntLit(5))))), App(Var(main$$1), Tup()))
//│ fun addOneTypedParam$1: (x: Int) -> Int
//│ fun main$$1: () -> Int
//│ Int
//│ res
//│     = 6

:mono
:rc
:p
fun min(x: Int, y: Int) = if x > y then y else x
min(3,4)
min(4,3)
//│ |#fun| |min|(|x|#:| |Int|,| |y|#:| |Int|)| |#=| |#if| |x| |>| |y| |#then| |y| |#else| |x|↵|min|(|3|,|4|)|↵|min|(|4|,|3|)|
//│ AST: TypingUnit(NuFunDef(None, min, None, [], Lam(Tup(x: Var(Int), y: Var(Int)), If(IfThen(App(Var(>), Tup(_: Var(x), _: Var(y))), Var(y), Some(Var(x))))), App(Var(min), Tup(_: IntLit(3), _: IntLit(4))), App(Var(min), Tup(_: IntLit(4), _: IntLit(3))))
//│ Parsed:
//│ TypingUnit(NuFunDef(None, min, None, [], Lam(Tup(x: Var(Int), y: Var(Int)), If(IfThen(App(Var(>), Tup(_: Var(x), _: Var(y))), Var(y), Some(Var(x))))), App(Var(min), Tup(_: IntLit(3), _: IntLit(4))), App(Var(min), Tup(_: IntLit(4), _: IntLit(3))))
//│ Lifted:
//│ TypingUnit {
//│   fun min$1 = (x: Int, y: Int,) => if (>(x, y,)) then y else x
//│   Code(List(min$1(3, 4,)))
//│   Code(List(min$1(4, 3,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun min$1(x, y) =
//│   if >(x, y) then y else x
//│ fun main$$2() =
//│   min$1(#4, #3)
//│ fun main$$1() =
//│   min$1(#3, #4)
//│ main$$1()
//│ main$$2()
//│ Parsed: TypingUnit(NuFunDef(None, min$1, None, [], Lam(Tup(x: Var(Int), y: Var(Int)), If(IfThen(App(Var(>), Tup(_: Var(x), _: Var(y))), Var(y), Some(Var(x))))), NuFunDef(None, main$$2, None, [], Lam(Tup(), App(Var(min$1), Tup(_: IntLit(4), _: IntLit(3))))), NuFunDef(None, main$$1, None, [], Lam(Tup(), App(Var(min$1), Tup(_: IntLit(3), _: IntLit(4))))), App(Var(main$$1), Tup()), App(Var(main$$2), Tup()))
//│ fun min$1: (x: Int, y: Int) -> Int
//│ fun main$$2: () -> Int
//│ fun main$$1: () -> Int
//│ Int
//│ res
//│     = 3
//│ res
//│     = 3

:mono
:p
:rc
class IntPlusY(x: Int) {
  val get =  x
}
val three = IntPlusY(5)
three.get
//│ |#class| |IntPlusY|(|x|#:| |Int|)| |{|→|#val| |get| |#=| |x|←|↵|}|↵|#val| |three| |#=| |IntPlusY|(|5|)|↵|three|.get|
//│ AST: TypingUnit(NuTypeDef(class, IntPlusY, (), Tup(x: Var(Int)), (), None, None, TypingUnit(NuFunDef(Some(false), get, None, [], Var(x)))), NuFunDef(Some(false), three, None, [], App(Var(IntPlusY), Tup(_: IntLit(5)))), Sel(Var(three), get))
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, IntPlusY, (), Tup(x: Var(Int)), (), None, None, TypingUnit(NuFunDef(Some(false), get, None, [], Var(x)))), NuFunDef(Some(false), three, None, [], App(Var(IntPlusY), Tup(_: IntLit(5)))), Sel(Var(three), get))
//│ Lifted:
//│ TypingUnit {
//│   class IntPlusY$1([x: Int,]) {let get = () => (this).x}
//│   let three$1 = () => IntPlusY$1(5,)
//│   Code(List((three).get))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ class IntPlusY$1(x) {
//│ }
//│ fun three$1() =
//│   IntPlusY$1(#5)
//│ fun main$$2() =
//│   three.get
//│ main$$2()
//│ Parsed: TypingUnit(NuTypeDef(class, IntPlusY$1, (), Tup(x: Var(Int)), (), None, None, TypingUnit()), NuFunDef(None, three$1, None, [], Lam(Tup(), App(Var(IntPlusY$1), Tup(_: IntLit(5))))), NuFunDef(None, main$$2, None, [], Lam(Tup(), Sel(Var(three), get))), App(Var(main$$2), Tup()))
//│ ╔══[ERROR] identifier not found: three
//│ ╙──
//│ class IntPlusY$1(x: Int)
//│ fun three$1: () -> IntPlusY$1
//│ fun main$$2: () -> error
//│ error
//│ Code generation encountered an error:
//│   unresolved symbol three
//| NuTypeDef(class, IntPlusY, (), Tup(x: Var(B)), (), None, None, TypingUnit(NuFunDef(None, get, None, [], Lam(Tup(_: Var(y)), Var(x))))), NuFunDef(Some(false), three, None, [], App(Var(IntPlusY), Tup(_: App(Var(B), Tup())))), App(Sel(Var(three), get), Tup(_: IntLit(1))))

:mono
:p
class IntPlusY(x: Int) {
  val get =  x
}
val three = IntPlusY(5)
three.get
//│ |#class| |IntPlusY|(|x|#:| |Int|)| |{|→|#val| |get| |#=| |x|←|↵|}|↵|#val| |three| |#=| |IntPlusY|(|5|)|↵|three|.get|
//│ AST: TypingUnit(NuTypeDef(class, IntPlusY, (), Tup(x: Var(Int)), (), None, None, TypingUnit(NuFunDef(Some(false), get, None, [], Var(x)))), NuFunDef(Some(false), three, None, [], App(Var(IntPlusY), Tup(_: IntLit(5)))), Sel(Var(three), get))
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, IntPlusY, (), Tup(x: Var(Int)), (), None, None, TypingUnit(NuFunDef(Some(false), get, None, [], Var(x)))), NuFunDef(Some(false), three, None, [], App(Var(IntPlusY), Tup(_: IntLit(5)))), Sel(Var(three), get))
//│ Lifted:
//│ TypingUnit {
//│   class IntPlusY$1([x: Int,]) {let get = () => (this).x}
//│   let three$1 = () => IntPlusY$1(5,)
//│   Code(List((three).get))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ class IntPlusY$1(x) {
//│ }
//│ fun three$1() =
//│   IntPlusY$1(#5)
//│ fun main$$2() =
//│   three.get
//│ main$$2()
//│ Parsed: TypingUnit(NuTypeDef(class, IntPlusY, (), Tup(x: Var(Int)), (), None, None, TypingUnit(NuFunDef(Some(false), get, None, [], Var(x)))), NuFunDef(Some(false), three, None, [], App(Var(IntPlusY), Tup(_: IntLit(5)))), Sel(Var(three), get))
//│ class IntPlusY(x: Int) {
//│   val get: Int
//│ }
//│ val three: IntPlusY
//│ Int
//│ three
//│       = IntPlusY {}
//│ res
//│     = 5
